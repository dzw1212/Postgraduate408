# 一、基本概念

## I. 数据结构

### 1. 三要素

**数据的逻辑结构**，如

​	集合：两个数据元素同属于一个集合；

​	线性结构：数据元素之间存在一对一的关系；

​	树形结构：数据元素之间存在一对多的关系；

**数据的存储结构**，如

​	顺序存储：逻辑上相邻的元素的物理存储位置也是相邻的；

​		优点 - 可以随机存取，每个元素占用最少的存储空间；

​		缺点：只能使用一整块内存，可能产生较多的内存碎片；

​	链式存储：存储位置不一定相邻，借助指针表示元素之间的逻辑关系；

​		优点：充分利用存储空间，不会产生内存碎片；

​		缺点：指针额外消耗内存空间，只能顺序存取而不能随机存取；

​	索引存储：存储的同时建立附加的索引表，记录元素的地址；

​		优点：搜索效率高；

​		缺点：增删速度需要修改索引表，因此效率低；索引表额外消耗内存空间；

​	散列存储：即哈希存储，根据元素关键字直接计算出存储地址；

​		优点：增删改查效率都高；

​		缺点：可能会产生存储位置冲突的问题，解决冲突问题额外消耗时间；

**数据的运算**

​	包括运算的定义和实现； 



Tips：

- 可以使用抽象数据类型（ADT）来定义一个完整的数据结构，如栈、队列、树、图，它们是以一种逻辑结构，没有限定必须使用哪一种物理结构来实现；
- 常见的物理（逻辑）结构：顺序表、链表（单链表、双向链表、循环链表），哈希表；
- 对于链式存储结构，结点与结点之间的存储单元地址不一定连续，但一个结点内的存储单元地址一定连续；
- 对于两种不同的数据结构，逻辑结构、物理结构、运算中总要有一个不相同，以区分两种数据结构；

## II. 算法

### 1. 效率的度量

#### 时间复杂度

一个语句的频度是指该语句被重复执行的次数，一个算法中所有语句的频度之和称为总频度，总频度的数量级称为算法的**时间复杂度**，记为$T(n)$；

一个算法中最深层的循环内的语句的频度$f(n)$与$T(n)$同一数量级，因此常用$f(n)$分析时间复杂度；
$$
T(n)=O(f(n))
$$
一般情况考虑的是最坏情况下的时间复杂度，以保证算法的运行时间不会超出这个值；

##### 常见比较

$$
O(1)<O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$

##### 运算规则

$$
O(f(n))+O(g(n))=O(max(f(n),g(n)))\\
O(f(n))\times O(g(n))=O(f(n)\times g(n))
$$

#### 空间复杂度

表示一个算法耗费的存储空间，记作$S(n)$；
$$
S(n)=O(g(n))
$$



Tips：

- 算法是对问题求解步骤的描述，程序则是算法的具体实现；
- 复杂度为$O(n)$的算法在时间上总是优于$O(n^2)$的算法，不用考虑$n$取特殊值时的情况；



# 二、线性表

## I. 定义

线性表是具有相同数据类型的$n$个数据元素的有限序列，表示数据元素之间前后排列的线性逻辑结构；

## II. 顺序表实现

顺序表使用一组地址连续的存储单元依次存储线性表中的数据，使得逻辑结构相邻的元素在物理结构上也相邻；

### 1. 静态分配与动态分配

静态分配：定义线性表时就设置好数组的长度，使用时无法改变；

```C
#define MAX_SIZE = 100
typedef struct
{
    ElemType data[MAX_SIZE];
    int length;
}ExamList;
```

动态分配：定义线性表时只填写元素的指针，运行时再设置数组的长度；

```c
typedef struct
{
    ElemType *data;
    int length;
}ExamList;

data = (ElemType *)malloc(sizeof(ElemType) * nListLength);
```

### 2. 特点

支持随机访问，可以通过下标在$O(1)$的时间复杂度内找到对应的元素；

存储密度高；

插入和删除时需要移动大量的元素，效率低；

### 3. 时间复杂度

| 操作       | 时间复杂度                           |
| ---------- | ------------------------------------ |
| 插入       | $O(n)$                               |
| 删除       | $O(n)$                               |
| 按值查找   | $O(n)$（无序），$O(\log_2n)$（有序） |
| 按下标查找 | $O(1)$                               |

## III. 链表实现

每个节点中除了保存元素本身的信息外，还需要一个指向下一个节点的指针，来建立元素之间的线性关系；

### 1. 单链表

#### 1. 头指针与头结点

使用头指针和头结点来标识一个链表，头指针一般指向头结点，当头指针指向`null`时，表示头结点不存在，即该链表不存在；同时方便运算操作的实现，不用特殊判断第一个结点；

```c
typedef struct LNode
{
    ElemType data;
    struct LNode *next;
}LNode, *List;
```

#### 2. 时间复杂度

| 操作                                  | 时间复杂度 |
| ------------------------------------- | ---------- |
| 根据下标，插入/删除元素               | $O(n)$     |
| 已知结点，在其之前或之后插入/删除元素 | $O(1)$     |
| 根据下标查找                          | $O(n)$     |

### 2. 分类

|              | 特点                                                         |
| ------------ | ------------------------------------------------------------ |
| 单链表       | 只有一个指向下一个结点的`next`指针，因此只能从头开始依次向后遍历； |
| 双向链表     | 有指针`prior`指向上一个结点和指针`next`指向下一个结点；      |
| 单向循环链表 | 将尾结点的`next`指针指向头结点，从而形成一个循环；           |
| 双向循环链表 | 不仅将尾结点的`next`指针指向头结点，还要将头指针的`prior`指针指向尾结点； |

对于单向循环链表，可以不设头指针而仅仅设尾指针，这样可以使得对于表头和表尾的操作效率更高；

### 3. 静态链表

借助数组来描述链式存储结构，需要提前在内存中申请一段连续的存储空间；

使用数组的小标作为指针，表示下一个结点的位置，指向-1的结点为最后一个结点；

![image-20210708020801692](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210708020801692.png)

静态链表通常用于在不支持指针的语言中实现链表，其插入删除等操作与动态链表的复杂度相同；



## IV. 两种实现的比较

顺序表支持随机访问，链表只能从表头开始顺序访问；

若需要频繁的查找，选择线性表实现；

若需要频繁的插入删除，则选择链表实现；



Tips：

- 链式存储结构相比顺序存储结构能更方便地表示各种逻辑结构；
- 基于比较的排序算法的最低时间复杂度为$O(n\log_2n)$；

# 三、栈与队列

## I. 栈

栈 --- 只能在一端进行插入或删除操作的线性表；

LIFO（后进先出）；

### 1. 顺性栈-共享栈

利用栈的栈底位置不变的特点，让两个栈共享一个一维数组空间；

仅当两个栈的栈顶相邻时，判断为栈满，两个栈的长度互相调节，从而更有效地利用存储空间；

![image-20210708023730636](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210708023730636.png)

### 2. 链栈

即采用链式存储结构的栈；

一般设除头结点外的第一个结点为栈顶指针，最后一个结点为栈底指针；

![image-20210708222209941](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210708222209941.png)

限制只能头结点进行插入和删除操作；



Tips：

- 线性表、栈、队列都属于同一种逻辑结构，即线性结构，它们可以用相同的物理结构实现（顺序表、链表），它们之间不同的是运算；
- 对于$n$个不同元素进栈，出栈序列的个数称为卡特兰数，为$\frac{1}{n+1}\frac{(2n)!}{n!\times n!}$；



## II. 队列

队列 --- 只允许在一端插入、在另一端删除的线性表；

FIFO（先进先出）；

一般设队首为可以删除的一端，队尾为可以插入的一端；

### 1. 顺序队列

#### 上溢出

![image-20210709010428909](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210709010428909.png)

当队列状态从全满到全部移出后，队首和队尾都到了顺序表的末端，此时虽然顺序表有空余空间，但无法再继续插入新的元素，称为**上溢出状态**；

#### 循环队列

将顺序表幻想为一个环，当$front=MaxSize-1$时，再插入一个元素，就将$front$重置为0（通过取余实现）；

初始时，$front=rear=0$；

插入一个元素时，队尾加一，$rear=(rear+1)\%MaxSize$；

删除一个元素时，队首加一，$front=(front+1)\%MaxSize$；

队伍长度 = $(rear-front+MaxSize)\%MaxSize$；

![image-20210709011033474](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210709011033474.png)

当循环队列为**空**和为**满**时，都有$front=rear$，因此需要方法来区别**空**和**满**状态：

方法①：

​	牺牲一个队列单元，比如一个循环队列总共有6个位置，规定当有5个元素时队列为满，此时队列为满的条件是$front=(rear+1)\%MaxSize$；

方法②：

​	循环队列结构体中增加一个成员变量$memberNum$用于记录成员数量，队列为满的条件是$memberNum=MaxSize$；

方法③：

​	循环队列结构体中新增一个成员变量$bIsFull$用于记录是否满员，队列为满的条件是$bIsFull=true$；

### 2. 链式队列

链式队列特别适合数据元素变动较大的情况，并且不存在队列满或溢出的问题；

### 3. 双端队列

两端都允许插入和删除操作的队列；

**输入受限的双端队列**

一端可以插入和删除，另一端只能删除；

**输出受限的双端队列**

一端可以插入和删除，另一端只能插入；



PS. 双端队列破坏了队列FIFO的性质；



Tips：

- 最适合用作链队列的链表是 带队首指针和队尾指针的非循环单链表；最不适合用作链队列的链表是 只带队首指针的非循环单链表（插入元素时需要遍历一遍才能找到尾指针）；
- 链队列删除元素时，一般只需要修改头指针即可，但是当队列中只有一个元素时，需要同步修改尾指针；



## III. 栈和队列的应用

栈用于括号匹配；

栈用在表达式按优先级运算求值时；

​	**后缀表达式** - 将计算符号直接写在其两个操作数的后面；

​		如$a*(b+c)-d$的后缀表达式为：$[bc+] \to [abc+*] \to [abc+*d-]$；

​		后缀表达式利于计算机进行计算出；

​	**中缀表达式** - 即常用的算术表达式；

​	

栈用于将递归算法转为非递归算法；

队列用于二叉树层次遍历、图的广度优先搜索；

队列用于计算机硬件之间数据、消息传输；



Tips：

- 求用栈求算术表达式的值时所需栈的深度时，转为后缀表达式求解：

    例1、$A-B*(C-D)$，转为后缀表达式：$ABCD-*-$，所需栈的深度为4；

    例2、$(A-B)*(C-D)$，转为后缀表达式：AB-CD-*，所需栈的深度为3；

- 非递归算法的效率一般比递归算法高，因此常借助栈将递归转为非递归；
- 
