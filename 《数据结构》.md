# 一、基本概念

## I. 数据结构

### 1. 三要素

**数据的逻辑结构**，如

​	集合：两个数据元素同属于一个集合；

​	线性结构：数据元素之间存在一对一的关系；

​	树形结构：数据元素之间存在一对多的关系；

**数据的存储结构**，如

​	顺序存储：逻辑上相邻的元素的物理存储位置也是相邻的；

​		优点 - 可以随机存取，每个元素占用最少的存储空间；

​		缺点：只能使用一整块内存，可能产生较多的内存碎片；

​	链式存储：存储位置不一定相邻，借助指针表示元素之间的逻辑关系；

​		优点：充分利用存储空间，不会产生内存碎片；

​		缺点：指针额外消耗内存空间，只能顺序存取而不能随机存取；

​	索引存储：存储的同时建立附加的索引表，记录元素的地址；

​		优点：搜索效率高；

​		缺点：增删速度需要修改索引表，因此效率低；索引表额外消耗内存空间；

​	散列存储：即哈希存储，根据元素关键字直接计算出存储地址；

​		优点：增删改查效率都高；

​		缺点：可能会产生存储位置冲突的问题，解决冲突问题额外消耗时间；

**数据的运算**

​	包括运算的定义和实现； 



Tips：

- 可以使用抽象数据类型（ADT）来定义一个完整的数据结构，如栈、队列、树、图，它们是以一种逻辑结构，没有限定必须使用哪一种物理结构来实现；
- 常见的物理（逻辑）结构：顺序表、链表（单链表、双向链表、循环链表），哈希表；
- 对于链式存储结构，结点与结点之间的存储单元地址不一定连续，但一个结点内的存储单元地址一定连续；
- 对于两种不同的数据结构，逻辑结构、物理结构、运算中总要有一个不相同，以区分两种数据结构；

## II. 算法

### 1. 效率的度量

#### 时间复杂度

一个语句的频度是指该语句被重复执行的次数，一个算法中所有语句的频度之和称为总频度，总频度的数量级称为算法的**时间复杂度**，记为$T(n)$；

一个算法中最深层的循环内的语句的频度$f(n)$与$T(n)$同一数量级，因此常用$f(n)$分析时间复杂度；
$$
T(n)=O(f(n))
$$
一般情况考虑的是最坏情况下的时间复杂度，以保证算法的运行时间不会超出这个值；

##### 常见比较

$$
O(1)<O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$

##### 运算规则

$$
O(f(n))+O(g(n))=O(max(f(n),g(n)))\\
O(f(n))\times O(g(n))=O(f(n)\times g(n))
$$

#### 空间复杂度

表示一个算法耗费的存储空间，记作$S(n)$；
$$
S(n)=O(g(n))
$$



Tips：

- 算法是对问题求解步骤的描述，程序则是算法的具体实现；
- 复杂度为$O(n)$的算法在时间上总是优于$O(n^2)$的算法，不用考虑$n$取特殊值时的情况；



# 二、线性表

## I. 定义

线性表是具有相同数据类型的$n$个数据元素的有限序列，表示数据元素之间前后排列的线性逻辑结构；

## II. 顺序表实现

顺序表使用一组地址连续的存储单元依次存储线性表中的数据，使得逻辑结构相邻的元素在物理结构上也相邻；

### 1. 静态分配与动态分配

静态分配：定义线性表时就设置好数组的长度，使用时无法改变；

```C
#define MAX_SIZE = 100
typedef struct
{
    ElemType data[MAX_SIZE];
    int length;
}ExamList;
```

动态分配：定义线性表时只填写元素的指针，运行时再设置数组的长度；

```c
typedef struct
{
    ElemType *data;
    int length;
}ExamList;

data = (ElemType *)malloc(sizeof(ElemType) * nListLength);
```

### 2. 特点

支持随机访问，可以通过下标在$O(1)$的时间复杂度内找到对应的元素；

存储密度高；

插入和删除时需要移动大量的元素，效率低；

### 3. 时间复杂度

| 操作       | 时间复杂度                           |
| ---------- | ------------------------------------ |
| 插入       | $O(n)$                               |
| 删除       | $O(n)$                               |
| 按值查找   | $O(n)$（无序），$O(\log_2n)$（有序） |
| 按下标查找 | $O(1)$                               |

## III. 链表实现

每个节点中除了保存元素本身的信息外，还需要一个指向下一个节点的指针，来建立元素之间的线性关系；

### 1. 单链表

#### 1. 头指针与头结点

使用头指针和头结点来标识一个链表，头指针一般指向头结点，当头指针指向`null`时，表示头结点不存在，即该链表不存在；同时方便运算操作的实现，不用特殊判断第一个结点；

```c
typedef struct LNode
{
    ElemType data;
    struct LNode *next;
}LNode, *List;
```

#### 2. 时间复杂度

| 操作                                  | 时间复杂度 |
| ------------------------------------- | ---------- |
| 根据下标，插入/删除元素               | $O(n)$     |
| 已知结点，在其之前或之后插入/删除元素 | $O(1)$     |
| 根据下标查找                          | $O(n)$     |

### 2. 分类

|              | 特点                                                         |
| ------------ | ------------------------------------------------------------ |
| 单链表       | 只有一个指向下一个结点的`next`指针，因此只能从头开始依次向后遍历； |
| 双向链表     | 有指针`prior`指向上一个结点和指针`next`指向下一个结点；      |
| 单向循环链表 | 将尾结点的`next`指针指向头结点，从而形成一个循环；           |
| 双向循环链表 | 不仅将尾结点的`next`指针指向头结点，还要将头指针的`prior`指针指向尾结点； |

对于单向循环链表，可以不设头指针而仅仅设尾指针，这样可以使得对于表头和表尾的操作效率更高；

### 3. 静态链表

借助数组来描述链式存储结构，需要提前在内存中申请一段连续的存储空间；

使用数组的小标作为指针，表示下一个结点的位置，指向-1的结点为最后一个结点；

![image-20210708020801692](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210708020801692.png)

静态链表通常用于在不支持指针的语言中实现链表，其插入删除等操作与动态链表的复杂度相同；



## IV. 两种实现的比较

顺序表支持随机访问，链表只能从表头开始顺序访问；

若需要频繁的查找，选择线性表实现；

若需要频繁的插入删除，则选择链表实现；



Tips：

- 链式存储结构相比顺序存储结构能更方便地表示各种逻辑结构；
- 基于比较的排序算法的最低时间复杂度为$O(n\log_2n)$；

# 三、栈与队列

## I. 栈

栈 --- 只能在一端进行插入或删除操作的线性表；

LIFO（后进先出）；

### 1. 顺性栈-共享栈

利用栈的栈底位置不变的特点，让两个栈共享一个一维数组空间；

仅当两个栈的栈顶相邻时，判断为栈满，两个栈的长度互相调节，从而更有效地利用存储空间；

![image-20210708023730636](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210708023730636.png)

### 2. 链栈

即采用链式存储结构的栈；

一般设除头结点外的第一个结点为栈顶指针，最后一个结点为栈底指针；

![image-20210708222209941](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210708222209941.png)

限制只能头结点进行插入和删除操作；



Tips：

- 线性表、栈、队列都属于同一种逻辑结构，即线性结构，它们可以用相同的物理结构实现（顺序表、链表），它们之间不同的是运算；
- 对于$n$个不同元素进栈，出栈序列的个数称为卡特兰数，为$\frac{1}{n+1}\frac{(2n)!}{n!\times n!}$；



## II. 队列

队列 --- 只允许在一端插入、在另一端删除的线性表；

FIFO（先进先出）；

一般设队首为可以删除的一端，队尾为可以插入的一端；

### 1. 顺序队列

#### 上溢出

![image-20210709010428909](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210709010428909.png)

当队列状态从全满到全部移出后，队首和队尾都到了顺序表的末端，此时虽然顺序表有空余空间，但无法再继续插入新的元素，称为**上溢出状态**；

#### 循环队列

将顺序表幻想为一个环，当$front=MaxSize-1$时，再插入一个元素，就将$front$重置为0（通过取余实现）；

初始时，$front=rear=0$；

插入一个元素时，队尾加一，$rear=(rear+1)\%MaxSize$；

删除一个元素时，队首加一，$front=(front+1)\%MaxSize$；

队伍长度 = $(rear-front+MaxSize)\%MaxSize$；

![image-20210709011033474](C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210709011033474.png)

当循环队列为**空**和为**满**时，都有$front=rear$，因此需要方法来区别**空**和**满**状态：

方法①：

​	牺牲一个队列单元，比如一个循环队列总共有6个位置，规定当有5个元素时队列为满，此时队列为满的条件是$front=(rear+1)\%MaxSize$；

方法②：

​	循环队列结构体中增加一个成员变量$memberNum$用于记录成员数量，队列为满的条件是$memberNum=MaxSize$；

方法③：

​	循环队列结构体中新增一个成员变量$bIsFull$用于记录是否满员，队列为满的条件是$bIsFull=true$；

### 2. 链式队列

链式队列特别适合数据元素变动较大的情况，并且不存在队列满或溢出的问题；

### 3. 双端队列

两端都允许插入和删除操作的队列；

**输入受限的双端队列**

一端可以插入和删除，另一端只能删除；

**输出受限的双端队列**

一端可以插入和删除，另一端只能插入；



PS. 双端队列破坏了队列FIFO的性质；



Tips：

- 最适合用作链队列的链表是 带队首指针和队尾指针的非循环单链表；最不适合用作链队列的链表是 只带队首指针的非循环单链表（插入元素时需要遍历一遍才能找到尾指针）；
- 链队列删除元素时，一般只需要修改头指针即可，但是当队列中只有一个元素时，需要同步修改尾指针；



## III. 栈和队列的应用

栈用于括号匹配；

栈用在表达式按优先级运算求值时；

​	**后缀表达式** - 将计算符号直接写在其两个操作数的后面；

​		如$a*(b+c)-d$的后缀表达式为：$[bc+] \to [abc+*] \to [abc+*d-]$；

​		后缀表达式利于计算机进行计算出；

​	**中缀表达式** - 即常用的算术表达式；

​	例、中缀表达式转后缀表达式，求所需要的栈的深度；

​	(1) $A-B*(C-D)$，转为后缀表达式：$ABCD-*-$，所需栈的深度为4；

​	(2) $(A-B)*(C-D)$，转为后缀表达式：AB-CD-*，所需栈的深度为3；

​	例、中缀表达式转后缀表达式，求栈中的操作符有哪些；

​	(1) 表达式为$a+b-a*((c+d)/e-f)+g$，

​		栈中的操作符的变化为：$+$

​												$(null)$

​												$-$

​												$-*$

​												$-*($

​												$-*(($

​												$-*((+$

​												$-*(($

​												$-*($

​												$......$

​		因此最多的时候，栈中同时存在5个操作符；

​	(2) 表达式为$a/b+(c*d-e*f)/g$，

​		当运算到$f$时，栈中的操作符为$+(-*$；



栈用于将递归算法转为非递归算法；

队列用于二叉树层次遍历、图的广度优先搜索；

队列用于计算机硬件之间数据、消息传输；



Tips：

- 求用栈求算术表达式的值时所需栈的深度时，转为后缀表达式求解；求某时刻栈中操作符时，观察中缀表达式更为直观；

- 非递归算法的效率一般比递归算法高，因此常借助栈将递归转为非递归；



## IV. 特殊矩阵与压缩存储

### 1. 数组

数组可以看作是线性表的推广，一维数组即为线性表，二维数组为元素是线性表的线性表，依次类推；

数组的所有元素在内存中占用一段连续的空间，其存储顺序有两种：

​	**按行优先**：$a_{00},a_{01},a_{02},a_{10},a_{11},a_{12}$；

​	**按列优先**：$a_{00},a_{10},a_{01},a_{11},a_{02},a_{12}$；

### 2. 压缩存储

特殊矩阵的元素分布具有规律，可借此此规律，对这种特殊矩阵的存储进行压缩；

如：

​	对称矩阵，

​		由于元素沿对角线对称，因此只需要存储上三角区或者下三角区的元素即可；

​	稀疏矩阵（零元素占绝大多数的矩阵），

​		存储非零元素的值与其对应的行和列；

# 四、树与二叉树

## I. 树

树是$n$个结点的有限集合，对于一颗非空的树：

(1) 有且仅有一个**根结点**；

(2) 除根结点之外的所以节点有且仅有一个**父结点**；

(3) 所以结点可以有零个或者多个**子结点**；



树中一个结点的子结点个数称为该结点的**度**，树中结点的最大度数称为**树的度**；

有子结点的结点称为**分支结点(非终端结点)**，没有子结点的结点称为**叶子结点(终端结点)**；

结点的**深度**为从根结点开始向下到自身的层数；

结点的**高度**为从自身开始向下到最底层叶子结点的层数；

**树的高度**即为根结点的高度；

多个互不相交的树构成一个**森林**；

**树的路径长度**为根结点到每个结点的路径长度的总和；

根结点到任意结点的**路径长度的最大值**为树的高度 - 1；



### 性质

① 树的结点数为其所有结点的度数 + 1；

② 高度为$h$的$m$叉树最多有$\frac{m^h-1}{m-1}$个结点；



## II. 二叉树

二叉树是限定每个结点最多有两个子结点的树（即树的度 $\leqslant 2$）；

两个子树分别称为**左子树**和**右子树**；

### 特殊的二叉树

#### 满二叉树

满二叉树的每个除叶子结点之外的结点都有2个子结点；

| 层数 | 结点个数  |
| ---- | --------- |
| 1    | 1         |
| 2    | 2         |
| 3    | 4         |
| ...  | ...       |
| $n$  | $2^{n-1}$ |

高度为$h$的满二叉树，结点总个数为$2^h-1$；

#### 完全二叉树

完全二叉树不要求每个分支结点都必须有2个子结点，但要求结点编号与满二叉树一一对应；

因此，

高度为$h$的完全二叉树，其叶子结点只可能在第$h$层或第$h-1$层出现；

结点个数为$n$的完全二叉树，对于编号为$i$的结点，如果$i \leqslant \lfloor \frac{n}{2} \rfloor$，则该结点为分支结点，否则为叶子结点；

#### 二叉排序树

二叉排序树具有如下性质：左子树上所有结点的数字都小于根结点，右子树上所有结点的数字都大于根结点，该性质对于每个结点均成立；

#### 平衡二叉树

任意一个结点的左子树与右子树的深度差不超过1；

### 性质

(1) 非空二叉树的叶子结点个数为度为2的结点个数 + 1，即$n_0=n_2+1$；

(2) 非空二叉树的第$k$层至多有$2^{k-1}$个结点；

(3) 高度为$h$的二叉树至多总共有$2^h-1$个结点；

(4) 具有$n$个结点的满二叉树的高度为$\log_2(n+1)$，对应的，具有$n$个结点的完全二叉树的高度为$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2n+1 \rfloor$（向上取整或向下取整）；



Tips：

- 一个具有$n$个结点的二叉树，其高度的范围是$[\lceil \log_2(n+1) \rceil,n]$（对应完全二叉树和单二叉树的情况）；

- 一个完全二叉树在第$h$层有叶子节点，则该完全二叉树的层数为$h$层或者$h+1$层；

  例、一棵完全二叉树的第6层有8个叶子结点，求该完全二叉树的结点的个数范围；

  解：因为在第6层有叶子结点，因此该完全二叉树有6层或者7层；

  ​		(1) 结点最少的情况下假设有6层，则前5层为满二叉树，第6层有只有8个叶子结点，

  ​			结点数为$2^5-1+8=39$；

  ​		(2) 结点最多的情况下假设有7层，则前6层为满二叉树，第6层应该有32个结点，其中8个为叶子结点，

  ​			则对应的第7层中相比满二叉树的情况下少了16个叶子结点，结点树为$2^7-1-16=111$；

  ​		因此该完全二叉树的结点的范围为$[39,111]$；

### 遍历

#### 先序遍历

根，左，右

```c
void PreOrder(BiTree *T)
{
    if (T)
    {
        visit(T);
        PreOrder(T->lChild);
        PreOrder(T->rChild);
    }
}
```

#### 中序遍历

左，根，右

```c
void InOrder(BiTree *T)
{
    if (T)
    {
        InOrder(T->lChild);
        visit(T);
        InOrder(T->rChild);
    }
}
```

#### 后序遍历

左，右，根

```c
void PostOrder(BiTree *T)
{
	if (T)
    {
        PostOrder(T->lChild);
        PostOrder(T->rChild);
        visit(T);
    }
}
```

#### 层次遍历

从左到右，一层一层地遍历；

```c
void LevelOrder(BiTree* T, bool bIsTopLevel)
{
	if (T)
	{
		if (bIsTopLevel)
			visit(T);
		visit(T->lChild);
		visit(T->rChild);
		LevelOrder(T->lChild, false);
		LevelOrder(T->rChild, false);
	}
}
```

#### 递归转非递归

借助栈实现；

#### 通过遍历确定二叉树

先序遍历/后序遍历/层次遍历 + 中序遍历都可以唯一确定一棵二叉树；

先序遍历 + 后序遍历可以确定根结点，但无法区分左右子树；



### 线索二叉树

传统的二叉树链表中存在大量空指针，如果利用这些空指针区域存放结点的直接前驱或者后继结点，则可以加快运算的速度，此为构建线索二叉树的目的；

对于一个有$n$个结点的二叉树，其二叉树链表中有$n+1$个空指针；

#### 前驱与后继结点

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717020906120.png" alt="image-20210717020906120" style="zoom: 67%;" />

前驱与后继结点视选择的遍历方式而定；

如中序遍历中，序列为$DBEACF$，结点$E$的前驱结点为$B$，后继结点为$A$；

#### 线索化

如果一个结点没有左子树，则其左子树指针指向其前驱结点；

如果一个结点没有右子树，则其右子树指针指向其后继结点；

并增加两个标志位，用于指示指向的是左子树/右子树还是前驱/后继结点；

线索化后的二叉树称为**线索二叉树**；

#### 构建

一边遍历，一边设置指针的指向与标志位；

#### 遍历

线索二叉树的遍历不需要再借助递归，因为前驱与后继将所有结点都线性地连接在一起；



Tips：

- 无论是先序遍历、中序遍历还是后续遍历，对叶子结点的先后顺序都是一致的（叶子结点位于左子树和右子树，而三种遍历都是先访问左子树再访问右子树）；
- 如果二叉树的先序遍历与后续遍历的序列正好相反，则该二叉树的所有分支结点都只有左子树或者右子树，且该二叉树只有一个叶子结点；

- 二叉树是一种逻辑结构，但线索二叉树为一种物理结构；
- 一个有着$n$个结点的二叉树的二叉树链表有$n+1$个空指针，因此使用了这些空指针的线索二叉树的线索有$n+1$条；

- 二叉树线索化后，仍然不能有效解决后序线索二叉树求后序后继的问题，因此后序线索树的遍历仍然需要栈的支持；

- 先序或中序序列为$a_1,a_2,a_3,...,a_n$的不同的二叉树的个数为卡特兰数$\frac{1}{n+1}\frac{(2n)!}{n!\times n!}$；



## III. 树与森林

### 1. 树的存储结构

树的存储结构要求能反映出树中各个结点之间的关系；

#### 双亲表示法

使用一组连续的空间来存储每个结点，同时每个结点中增加一个指针（数组下标），用来表示其父结点在该数组中的位置；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717043348228.png" alt="image-20210717043348228" style="zoom:67%;" />

优点：容易得到某个结点的父结点；

缺点：若想知道某个结点的所有子结点，需要遍历整个存储结构；

#### 孩子表示法

每个结点对应一个链表，链表中为其所有的子结点；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717044903588.png" alt="image-20210717044903588" style="zoom:67%;" />

优点：容易得到所有子结点；

缺点：不容易找到父结点；

#### 孩子兄弟表示法

又称**二叉树表示法**；

每个结点包括三部分内容：自身的数值 + 指向第一个子结点的指针 + 指向下一个兄弟结点的指针；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717045852920.png" alt="image-20210717045852920" style="zoom:67%;" />

优点：可以方便的实现树到二叉树的转换，查找子结点方便；

缺点：不容易找到父结点；



### 2. 树、二叉树、森林的转换

#### 树 $\to$ 二叉树

每个结点的左指针指向其第一个子结点，右指针指向其相邻的兄弟结点，即“左孩子右兄弟”；

给定一棵树，可以找打唯一的一棵二叉树与之对应；

#### 森林 $\to$ 二叉树

将森林中每一棵树都转为对应的二叉树，把第一棵二叉树的根作为整个森林的根，然后再将第二棵二叉树的根作为第一棵二叉树的根的右子树，将第三棵二叉树的根作为第二棵二叉树的根的右子树，依次类推；

#### 二叉树 $\to$ 森林

即为森林转二叉树的逆过程：将二叉树的根结点及其左子树作为第一棵二叉树，根的右节点及该右节点的左子树作为第二棵二叉树，依次类推；

#### 二叉树 $\to$ 树

即为树转二叉树的逆过程：兄弟结点之间断开连线，右兄弟作为父结点的右子树



Tips：

- 树/森林$\to$二叉树时，

  树/森林中分支结点的个数与二叉树中右指针为空的结点个数一致；

  树/森林中叶子结点的个数与二叉树中左指针为空的结点个数一致；

- 树的先根遍历、后根遍历对应二叉树的先序遍历、中序遍历，因此可以通过树的先根和后根遍历序列推算出一棵唯一的树；

- 对于一棵树，其结点数量为$n$，则边的数量为$n-1$；



### 3. 树的应用

#### 并查集

并查集是一种简单的集合表示，它主要用于解决元素分组问题；

并查集管理一系列不相交的集合，并提供以下三种操作：

​	① 初始化`Initial(S)` - 将集合$S$中的每个元素都初始化为只有一个元素的子集合；

​	② 合并 `Union(S, Root1, Root2)` - 合并两个不相交的集合；

​	③ 查找`Find(S, x)` - 查找元素$x$所在的子集合；



通常使用双亲表示法作为并查集的存储结构；

初始化时，每个元素的指针指向-1，代表此时每个元素都是独立的子集合；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717201211064.png" alt="image-20210717201211064" style="zoom:67%;" />

```c
void Initial(int S[])
{
    for (int i = 0; i < size; ++i)
        S[i] = -1;
}
```

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717202029810.png" alt="image-20210717202029810" style="zoom:67%;" />

若要查找$E$所在的子集合（即父结点），直接访问$S[IndexOf(E)]$即可；

```c
int Find(int S[], int x){    while (S[x] >=)        return x;}
```

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210717203010851.png" alt="image-20210717203010851" style="zoom:67%;" />

将两棵树合并，只需改变根结点的父结点指针即可；

```c
void Union(int S[], int Root1, int Root2){    S[Root2] = Root1;}
```



## IV. 树与二叉树的应用

### 1. 二叉排序树(BST)

如果二叉排序树非空，则

​	若左子树非空，则左子树上所有结点的关键字值均小于根结点的关键字值；

​	若右子树非空，则右子树上所有结点的关键字值均大于根结点的关键字值；

​	左子树、右子树也分别是二叉排序树；

简单来说，即“左 < 根 < 右”；

因此，对二叉排序树进行中序遍历，可以得到一个递增的有序数列；

#### 查找

从根结点开始，如果要查找的值小于根，则继续从左子树开始查找；如果要查找的值大于根，则继续从右子树进行查找；

#### 插入

从根结点开始，如果结点不存在，则新增结点并插入；

若插入值小于根结点，则插入左子树；

若插入值大于根结点，则插入右子树；

#### 构造

依次往二叉排序树内插入元素；

#### 删除

分不同情况：

(1) 如果待删除结点是叶子结点，则直接删除；

(2) 如果待删除结点只有一棵左子树或者右子树，则让其左子树或右子树代替其原来的位置；

(3) 如果待删除结点既有左子树又有右子树，则令该结点的前驱或后继结点的值代替该结点的值，并删除这个用来替代的前驱或后继结点；

#### 效率

二叉排序树查找算法的平均查找长度与树的高度有关（即树的形态）：

​	若该树是仅有左孩子或仅有右孩子的单支树，类似于一个有序的单链表，则平均查找长度为$O(n)$；

​	若该树的左子树和右子树之间的高度差不大于1（此时又称平衡二叉树），则平均查找长度为$O(\log_2n)$；

二叉排序树的插入和删除操作无需移动结点只需要修改指针，平均执行时间为$O(\log_2n)$；



因此，

**静态查找表**（仅作查询操作）适合使用顺序表存储，采用二分查找算法实现；

**动态查找表**（查询的同时还要插入和删除操作）适合选择二叉排序树作为逻辑结构；



### 2. 平衡二叉树(AVL)

平衡二叉树是具有平衡性的二叉排序树；

如果平衡二叉树非空，则

​	左子树与右子树的高度差（又称该结点的**平衡因子**）的绝对值不大于1；

​	左子树和右子树也是平衡二叉树；

#### 插入

插入后需要保证二叉树仍然保持平衡性，因此需要在二叉排序树的插入的基础上，再进行旋转；

step 1. 插入元素

​	参考二叉排序树的插入；

step 2. 若不平衡，进行旋转；

​	(1) $LL$旋转（右单旋转）

​		原因：结点$A$的 左孩子 的 左子树 插入新结点，导致结点$A$的平衡因子$>1$；

​		方法：将结点$A$顺时针旋转一位，并将$A$的左孩子的右子树作为旋转后的$A$的左子树；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210718161310617.png" alt="image-20210718161310617" style="zoom:67%;" />

​	(2) $RR$旋转（左单旋转）

​		原因：结点$A$的 右孩子 的 右子树 插入新结点，导致结点$A$的平衡因子$<-1$；

​		方法：将结点$A$逆时针旋转一位，并将$A$的右孩子的左子树作为旋转后的$A$的右子树；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210718163251832.png" alt="image-20210718163251832" style="zoom:67%;" />

​	(3) $LR$旋转

​		原因：结点$A$的 左孩子 的 右子树 插入新结点，导致结点$A$的平衡因子$>1$；

​		方法：先将结点$B$逆时针旋转一位并移动子结点，再将结点$A$顺时针旋转一位并移动子结点；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210718164731046.png" alt="image-20210718164731046" style="zoom:67%;" />

​	(4) $RL$旋转

​		原因：结点$A$的 右孩子 的 左子树 插入新结点，导致结点$A$的平衡因子$<-1$；

​		方法：先将结点$C$顺时针旋转一位并移动子结点，再将结点$A$逆时针旋转一位并移动子结点；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210718170255793.png" alt="image-20210718170255793" style="zoom:67%;" />

#### 查找

平衡二叉树的查找与最优情况的二叉排序树的查找一致；

平均复杂度为$O(\log_2n)$；



### 3. 哈夫曼树

树中结点的数值为该结点的权$w$，到根结点的路径长度为该结点的路径长度$l$，两者的乘积称为该结点的**带权路径长度**，记为$wl$；

树中所有叶子结点的带权路径长度的和称为**树的带权路径长度**，记为$WPL$，
$$
WPL=\sum_{i=1}^n w_il_i
$$
在含有$n$个带权叶子结点的二叉树中，其中$WPL$最小的二叉树称为**哈夫曼树（最优二叉树）**；

#### 构造

① 将$n$个结点放入一个森林中；

② 新增一个结点，从森林中找出2个权值最小的结点，分别作为新增结点的左孩子和右孩子，新增结点的权值为两个孩子的权值之和；将新增结点放入森林中；

③ 重复步骤②，直到森林中只剩一棵树；

#### 性质

① 权值越大的结点离根结点越远；

② $n$个结点在构造过程中新增了$n-1$个结点，即叶子节点个数为$n$的哈夫曼树共有$2n-1$个结点；

③ 哈夫曼树中不存在度为1的点；

④ 哈夫曼树不一定是完全二叉树；

#### 哈夫曼编码

对于一段字符串，

​	如果每个字符用同样长度的二进制位表示，则为**固定长度编码**；

​	如果每个字符用不等长的二进制位表示，则为**可变长度编码**；

可变长度编码可以给使用频率高的字符较短的二进制位，从而起到压缩数据的效果；

哈夫曼编码是一种常见的可变长度编码的方法；



**前缀编码** - 若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码；





Tips：

- 平衡二叉树最少所需结点（此时所有非叶子结点的平衡因子为1）递推公式：

$$
\begin{align}
n_0&=0\\
n_1&=1\\
n_2&=2\\
n_3&=4\\
...\\
n_h&=1+n_{h-1}+n_{h-2}
\end{align}
$$

- 度为$m$的哈夫曼树，叶子结点个数为$n$，则非叶子结点个数为$\frac{n-1}{m-1}$；



# 五、图

## I. 基本概念

图$G$由顶点集$V$和边集$E$组成，记作$G=(V,E)$；

其中，$V(G)$​表示顶点的有限非空集合，$|V|$表示顶点个数，也称图$G$的阶；

​			$E(G)$表示边的集合，$|E|$表示边的个数；



带有方向的边称为**有向边**，使用$<begin,end>$​表示：

​	$V={v_1,v_2,v_3}$；

​	$E={<v_1,v_2>,<v_2,v_3>,<v_1,v_3>}$​

若$E$​为有向边的集合，则称为**有向图**，否则称为**无向图**；



**平行边**

对于无向边，为两个顶点间的两条直线；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210724002421968.png" alt="image-20210724002421968" style="zoom: 50%;" />

对于有向边，为两个顶点间方向相同的两条直线；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210724002658827.png" alt="image-20210724002658827" style="zoom:50%;" />

**自环**

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210724002937469.png" alt="image-20210724002937469" style="zoom:20%;" />



**简单图，多重图**

简单图 - 没有平行边或自环的图；

多重图 - 含有平行边或自环的图；



**完全图**

无向完全图 - 任意两个顶点之间都有边的五向图，若含有$n$个顶点，则边数为$\frac{n(n-1)}{2}$；

有向完全图 - 任意两个顶点之间都有两条方向相反的边，若含有$n$个顶点，则边数为$n(n-1)$；



**子图，生成子图**

设有两个图$G=(V,E)$和$G'=(V',E')$，若$V'$是$V$的子集，$E'$是$E$的子集，则称图$G'$为图$G$的子图；

若子图$G'$中包含$G$的所有顶点，则称$G'$是$G$的完全子图；



**连通图，连通分量**

在无向图中，如果从一个顶点到另一个顶点的路径存在，则称这两个顶点是连通的；

若一个无向图的任意两个顶点都是连通的，则称该图为连通图；

一个无向图中的极大连通子图为其连通分量； 



**极大/极小连通子图**

极大连通子图 - 在确保图连通的情况下，边数最多的子图；

极小连通子图 - 在确保图连通的情况下，边数最少的子图；



**强连通图，强连通分量**

有向图中的连通称为强连通；



**生成树，生成森林**

生成树 - 包含连通图中所有顶点的一个极小连通子图；

生成森林 - 非连通图的连通分量的生成树构成了生成森林；



**顶点的度，入度，出度**

顶点的度 - 以该顶点为端点的边的数量；

​	对于无向图，顶点$v$的度记作$TD(v)$；

​		在具有$n$个顶点，$e$条边的无向图中，因为每条边都连接两个顶点，因此有$\sum_{i=1}^nTD(v_i)=2e$；

​	对于有向图，顶点的度分为入度和出度，对应边的方向；

​		入度 - 以顶点$v$为终点的有向边的数量，记作$ID(v)$；

​		出度 - 以顶点$v$为起点的有向边的数量，记作$OD(v)$；

​		在具有$n$个顶点，$e$条边的有向图中，因为每条边都有一个起点和终点，因此有$\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=e$；



**边的权，网**

权 - 在一个图中，每条边都可以具有某种含义的数值，该数值称为这条边的权；

网 - 边带有权值的图称为带权图，又称为网；



**稠密图，稀疏图**

当图满足$E<V\log V$时，可以将该图视为稀疏图；

当图的边数很多时，为稠密图；



**路径，路径长度，回环**

两个顶点之间的路径为连通两个顶点的一条路线的所有顶点序列；

路径上的边的数目称为路径长度；

若顶点序列的起始点和终点为同一个顶点，则称该路径为回环；

​	若一个图有$n$个顶点且边的数目大于$n-1$，则该图中必然存在回环；



**简单路径，简单回路**

简单路径 - 顶点不重复出现的路径；

简单回路 - 除起点和终点外，再没有重复顶点的路径；



**距离**

两个顶点之间的距离指两个顶点之间的最短路径长度；

若没有路径可以连通，则距离为$+\infty$；



**有向树**

一个顶点的入度为0，其他顶点的入度均为1的有向图；



Tips：

- 如果一个无向图有$n+1$​个顶点，要保证该图在任何情况下都是连通的，需要的最少边数是多少？

解：最极端的情况，其中$n$​个顶点构成一个完全无向图，再加上一条边后，第$n+1$​个顶点必与完全无向图形成一个连通图；

​		$n$​​个顶点构成的完全无向图的边数为$\frac{n(n-1)}{2}$；

​		则需要的最少边数为$\frac{n(n-1)}{2}+1$；

- 一个具有$n$个顶点的有向环的生成树（极大连通子图）最多具有$n-1$个结点；​；



## II. 存储

### 1. 邻接矩阵法

用一个一维数组存储顶点的信息，用一个二维数组存储边的信息；

一个含有$n$个顶点的图$G=(V,E)$需要一个$n \times n$的邻接矩阵$A$，若$<v_i,v_j>\in E$，则$A[i][j]=1$，否则$A[i][j]=0$​​；

对于无向图，其临界矩阵是对称的；

对于有向图，需要考虑方向；

对于带权图，若两个顶点间有边，则存储权值$A[i][j]=w_{ij}$，否则$A[i][j]=0$或$\infty$​；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210725010407950.png" alt="image-20210725010407950" style="zoom: 50%;" />

#### 特点

(1) 无向图的临界矩阵为一定是一个对称矩阵，可以使用压缩存储；

(2) 无向图的临界矩阵的第$i$行非零元素的个数对应顶点$v_i$的度$TD(v_i)$；

(3) 有向图的邻接矩阵的第$i$行非零元素的个数对应顶点$v_i$的出度$OD(v_i)$或入度$ID(v_i)$；

(4) 邻接矩阵法适合表示两个顶点之间的关系，但不适合确定图中边的个数；

(5) 邻接矩阵法适合存储稠密图，不适合存储稀疏图；

(6) 设图$G$的邻接矩阵为$A$，则$A^n$的元素$A^n[i][j]$表示顶点$v_i$到$v_j$的路径长度为$n$的路径的个数；

### 2. 邻接表法

为图中的每个顶点建立一个单链表，第$i$个单链表中的链表结点表示依附于顶点$v_i$的边（对于有向图则是终点为顶点$v_i$的边），该单链表称为顶点$v_i$​的**边表**（对于有向图则称为**出边表**）；

结点表采用链式存储，边表的头指针和顶点数据采用顺序存储；

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210725011227362.png" alt="image-20210725011227362" style="zoom:50%;" />



#### 特点

(1) 若$G$为无向图，则所需存储空间为$O(V+2E)$；若$G$为有向图，则所需存储空间为$O(V+E)$；

(2) 邻接表法适合存储稀疏图，不适合存储稠密图；

(3) 邻接表中，给定一个顶点，很容易找到与之关联的边，但不容易确定两个顶点之间是否存在边；

(4) 在有向图的邻接表中，计算一个顶点的出度只需要计算其边表的结点个数，但若要求入度则需要遍历全部邻接表，因此若需要快速求出入度，可以采用逆邻接表存储；

(5) 邻接表的边表不唯一，因为结点的顺序可以是任意的；

### 3. 十字链表

一种针对有向图的链式存储结构；

### 4. 邻接多重表

一种针对无向图的链式存储结构；



## III. 图的遍历

从图的某一个顶点出发，按照某种搜索方法沿着图中的边，对图中的所有顶点进行访问且仅访问一次；

广度优先搜索会优先考虑最早被发现的顶点，离起点距离最近的顶点的优先级越高；

深度优先搜索会优先考虑最晚被发现的顶点；

### 1. 广度优先搜索BFS

类似二叉树的层序遍历，需要一个数组记录已经访问过的顶点，一个队列记录需要访问的顶点；

从起始顶点开始，依次访问邻接顶点，如果遇到访问过的就pass，没访问过的就访问并置位入队，把邻接顶点全部遍历一遍过后，从队列中出队一个顶点，再重复上述过程；

#### 复杂度

空间复杂度

​	对于邻接矩阵和邻接表，都是$O(V)$；

时间复杂度

​	对于邻接矩阵，为$O(V^2)$；

​	对于邻接表，为$O(V+E)$；

#### 广度优先生成树

在广度优先搜索过程中，得到的一棵遍历树；

根据邻接矩阵得到的广度优先生成树是唯一的，根据邻接表得到不唯一；

#### 应用

使用广度优先搜索，可以求解非带权图的单源最短路径问题；

### 2. 深度优先搜索DFS

类似二叉树的先序遍历（根左右）；

从起始顶点开始，访问第一个邻接顶点，如果遇到访问过的就pass，没访问过的就访问并置位入队，然后继续访问该顶点的第一个邻接顶点，重复上述步骤，直到没有邻接结点，再从其实顶点的第二个邻接顶点开始上述过程；

#### 复杂度

空间复杂度

​	对于邻接矩阵和邻接表，都是$O(V)$；

时间复杂度

​	对于邻接矩阵，为$O(V^2)$；

​	对于邻接表，为$O(V+E)$；

#### 深度优先生成树和森林

只有对连通图进行深度优先搜索才能生成深度优先生成树，否则生成的是深度优先生成森林；

根据邻接矩阵得到的广度优先生成树是唯一的，根据邻接表得到不唯一；

### 3. 遍历与连通性

图的遍历算法可以用来判断图的连通性；

对于无向图，如果无向图不是连通的，则一次遍历只能获取到起始顶点所在连通分量的所有顶点；对于有向图，如果有向图不是强连通的，则亦是如此；



Tips：

- 判断有向图中是否存在回路，可以利用拓扑排序或深度优先遍历算法；



## IV. 图的应用

### 1. 最小生成树

回顾一下生成树：一个连通图的生成树是其极小连通子树，包含图的所有顶点和尽可能少的边；

若生成树减少一条边，则不再连通；若生成树增加一条边，则会形成回路；

对于带权的连通无向图，存在树的权值的概念（即树中所有边的权值之和），权值之和最小的生成树被称为带权图的**最小生成树**；

可通过Prim算法或kruskal算法求得；

#### 性质

(1) 最小生成树不一定是唯一的（只有所有边的权值不重复时为唯一）；

(2) 最小生成树的边数为其顶点数-1；

(3) 如果图的边数为顶点数-1（即自身就是一棵树），则图的最小生成树就是图本身；

#### Prim算法

对于一个连通网$N=(V,E)$，

​	设$E_T$为$N$​的最小生成树的边的集合，

​	① 取$N$中任意顶点作为起始顶点$u_0$，设$V_T=\{u_0\},E_T=\{\}$​；

​	② 取顶点$u \in V_T,v \in V-V_T$​​​​两个顶点间权值最小的边，将该边加入$E_T$，将$v$加入$V_T$；

​	③ 重复步骤②，直到$V_T=T$，此时$E_T$中有$n-1$条边，$(V_T,E_T)$即为所求最小生成树；

##### 复杂度

时间复杂度为$O(V^2)$，适合稠密图；

#### Kruskal算法

对于一个连通网$N=(V,E)$，

​	① 设$V_T=V,E_T=\{\}$，即初始时$V_T$包含图中的所有顶点；

​	② 找到$E-E_T$中权值最小的边，若该边加入后不构成回路，则将该边加入$E_T$中，否则舍弃该边；

​	③ 重复步骤②，直到$E_T$中有$n-1$条边；

##### 复杂度

时间复杂度为$O(E\log E)$，适合稀疏图；

### 2. 最短路径

对于一个带权图，把两个顶点之间的边的权值之和定义为路径的**带权路径长度**，其中，带权路径长度最小的路径称为**最短路径**；

性质：通常，两个顶点之间的最短路径也包含了路径上其他顶点间的最短路径；

带权有向图的最短路径问题可分为两类：

 1. 单源最短路径

    求图中某一个顶点到其他各顶点的最短路径，可通过Dijkstra算法求解；

	2. 求每对顶点间的最短路径

    可通过Floyd-Warshall算法求解；

#### Dijkstra算法

常用于求带权有向图中某个源点到其他各顶点的最短路径；



① 设置一个集合$S$存放已求得最短路径的顶点，将源顶点放入$S$；

② 从$V-S$中找到与源顶点距离最近的点（边的权值最小），放入$S$中；

③ 重复步骤②，直到所有点都在$S$​中；



PS：对于权值存在负的带权有向图，Dijkstra并不适用；

##### 复杂度

对于邻接矩阵和邻接表，都是$O(V^2)$；

如果需要求出每两个顶点之间的最短路径，需要对每个顶点运行一次Dijkstra算法，总的时间复杂度为$O(V^3)$​；

#### Floyd算法

常用于求所有顶点之间的最短路径；

##### 复杂度

时间复杂度为$O(V^3)$；

### 3. 拓扑排序

如果一个有向图中不存在环，则称为**有向无环图**（DAG）；

若用DAG表示一个工程，顶点表示一个活动，边表示活动的前提条件，则这种工程称为**用顶点表示活动的网格**（AOV网）；

一个有向无环图的顶点组成的序列，当满足下列条件时被称为图的**拓扑排序**：

(1) 每个顶点都出现且仅出现一次；

(2) 若顶点$A$在序列中排在顶点$B$的前面，则图中不存在从$B$到$A$的路径；



每个有向无环图都有一个或多个拓扑排序序列；

常用的求拓扑排序的方法：

① 从DAG中选择一个没有前驱的顶点，输出该顶点；

② 从DAG中删除该顶点和所有以该顶点为起点的有向边；

③ 重复步骤②，直到DAG图为空，或不存在无前驱的顶点为止（说明有环）；



### 4. 关键路径

在一个DAG中，用顶点表示事件，用边表示活动，用边的权值表示活动的开销（活动的执行时间），则称这种有向图为**用边表示活动的网格**（AOE网）；

AOE网具有以下性质：

(1) 只有当顶点表示的事件发生后，从该顶点出发的边所表示的活动才能开始；

(2) 只有在进入某一顶点的边所表示的活动都结束后，该顶点表示的事件才能开始；

AOE网中只有一个入度为0的顶点，称为**开始顶点**（源点）；

AOE网中只有一个出度为0的顶点，称为**结束顶点**（汇点）；

AOE网中的活动可以并行执行，各个活动的执行时间不一样，只有等所有活动都结束了整个工程才算结束，因此从开始顶点到结束顶点的所有路径中，最长的路径称为**关键路径**，关键路径上的活动称为**关键活动**；



**事件$v_k$的最早发生时间$v_e(k)$**

​	指从开始顶点到顶点$v_k$​的最长路径的长度；

​	设开始顶点的$v_e(begin)=0$​；

​	计算方法：设事件$v_j$为其前一个事件，则$v_e(k)=v_e(j)+w_{jk}$；

**事件$v_k$的最晚发生时间$v_l(k)$**

​	指在保证其后一个时间$v_l$在$v_e(l)$时刻能够发生的该事件的最迟发生时间；

​	设结束顶点的$v_e(end)=v_l(end)$；

​	计算方法：设事件$v_l$为其后一个事件，则$v_l(k)=v_l(l)-w_{kl}$；

**活动$a_i$的最早开始时间$e(i)$**

​	表示该活动的边的起点的事件的最早发生时间；

​	计算方法：若$<v_i,v_j>$​​表示活动$a_i$，则$e(i)=v_e(i)$；

**活动$a_i$的最晚开始时间$l(i)$**

​	表示该活动的边的终点的事件的最迟发生时间于该活动所需时间的差；

​	计算方法：若$<v_i,v_j>$表示活动$a_i$，则$l(i)=v_l(j)-w_{ij}$；

**活动$a_i$差额$d(i)$**

​	表示活动最多可以拖延的时间；

​	差额为0的活动即为关键活动；

​	计算方法：$d(i)=l(i)-e(i)$；



求关键路径的步骤：

① 求出所有事件的最早发生时间$v_e$和最晚发生时间$v_l$；

② 求出所有活动的最早开始时间$e$和最晚开始时间$l$；

③ 求出所有活动的差额，找出差额为0的关键活动；

④ 关键活动组成的路径即为关键路径；



可以通过缩短关键活动来缩短整个工程的工期，但是：

(1) 关键路径不唯一，只缩短一个关键活动不一定能缩短整个工程工期，需要找到所有关键路径共有的那一个关键活动；

(2) 不能无限制的缩短关键活动，一旦缩短到一定程序则关键活动会变为非关键活动；



Tips：

- Prim算法和kruskal算法得到最小生成树不一定相同，但是当各边的权值不同时（此时最小生成树唯一），这两种算法得到的最小生成树相同；
- 最短路径一定是简单路径；
- 判断一个有向图是否有环的方法有：深度优先遍历、拓扑排序、求关键路径；
- 若一个有向图不存在拓扑排序，则该图中必定至少存在一个回路，这个回路构成一个强连通分量；
- 拓扑排序唯一，并不代表图是线性的；拓扑排序唯一，也不能唯一确定一个图；



# 六、查找

## I. 相关概念

**查找表**

用于查找的数据集合；

**静态、动态查找表**

静态查找表 - 只查找；

​	适合顺序查找、折半查找等；

动态查找表 - 查找的同时动态地插入或删除元素；

​	适合二分查找、散列查找等；

**平均查找长度ASL**

查找过程中进行关键字的比较次数的平均值，为衡量查找算法效率的主要指标；

## II. 常见查找方法

### 1. 顺序查找

#### 对无序表查找

$ASL_{success}=\frac{n+1}{2}$

$ASL_{fail}=n+1$

优点：对数据元素的存储方式没有要求，可以顺序存储也可以链式存储；

缺点：当数据元素的个数很多时，效率低下；

#### 对有序表查找

由于直到数据是有序的，因此可以大大降低查找失败时的ASL；

$ASL_{fail} = \frac{n}{2}+\frac{n}{n+1}$；

### 2. 折半查找

前提：有序的顺序表；

折半查找的过程可用二叉树来描述，对应的二叉树称为**判定树**；

若查找的有序序列的长度为$n$​，则对应的判定树有$n$​个分支结点和$n+1$​个叶子节点；



二叉判定树的绘制：

​	原则：

​		① 每个结点的平衡因子（左子树高度 - 右子树高度）为-1或0；

​		② 无法除尽时向下取整；

​	比如对$1~9$进行折半排序，

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210726205951623.png" alt="image-20210726205951623" style="zoom: 33%;" />

​		此时的$ASL_{success}=\frac{1}{9}(1+2*2+3*4+4*2)=\frac{25}{9}$​，$ASL_{fail}=\frac{1}{10}(3*6+4*4)=\frac{34}{10}$​；

折半查找需要用到随机存取性质，因此不适用于链式存储结构；

### 3. 分块查找

将查找表分为若干子块，块内可以无序，块之间保持有序；

查找表中元素数目为$n$，分成$s$块，每块内元素数目为$b=\frac{n}{s}$，则$ASL=\frac{s^2+2s+n}{2s}$；

当$b=\sqrt{n}$​时，有$ASL_{min}=\sqrt{n}+1$；​



Tips：

- 二叉判定树是一棵平衡二叉树；

- 折半查找中，查找失败时，

  ​	最少查找次数为二叉判定树的最小高度，即$h_{min} = \lfloor \log_2(n+1)\rfloor$；

  ​	最多查找次数为二叉判定树的高度，即$h_{max} = \lceil \log_2(n+1)\rceil$；

- 折半查找与二叉排序树查找：

  ​	折半查找的最大查找长度 = 平均查找长度 = $O(\log_2n)$；

  ​	二叉排序树查找的最大查找长度（单支树）= $O(n)$，平均查找长度 = $O(\log_2n)$；



## III. B树和B+树

### 1. B树

B树，又称**多路平衡查找树**；

B树的所有结点中孩子结点数的最大值称为**B树的阶**，通常用$m$表示；

一棵阶为$m$的B树或为空树，或满足以下性质：

​	(1) 树中每个结点最多有$m$​​棵子树，$m-1$个关键字（关键字用于分区子树，比如$i$个关键字就有$i+1$棵子树）；

​	(2) 除根结点外的所有分支结点至少有$\lceil m/2 \rceil$棵子树；

​	(3) 所有分支结点的结构如下：

​		$n,P_0,K_1,P_1,K_2,P_2,...,K_n,P_n$

​		其中$K_i(i\in[1,n])$​为结点的关键字，满足$K_1<K_2<...<K_n$​​；

​		其中$P_i(i\in[0,n])$为指向子树的根结点的指针，并且

​			$P_{i-1}$所指向的子树中的所有结点的关键字都小于$K_i$​，

​			$P_i$所指向的子树中的所有结点的关键字都大于$K_i$​；

​		其中$n$为结点中关键字的个数；

​	(4) 所有叶子结点都在同一层，并且不带任何信息；

​	(5) 所有结点的平衡因子均为0；

#### 高度

B树的大部分操作所需的磁盘读写次数与B树的高度相关；

B树的高度一般不包括最后一层的叶子结点；

若关键词个数$n \geqslant 1$​，高度为$h$，阶数为$m$，则

​	(1) 每个结点最多有$m$棵子树，$m-1$个关键字，因此有$n \leqslant m^h-1$，对应的$h \geqslant \log_m{(n+1)}$；

​	(2) 每个结点最少有$\lceil m/2\rceil$棵子树，有$n \geqslant 2(\lceil m/2\rceil)^{h-1}-1$，对应的$h \leqslant \log_{\lceil m/2\rceil}(\frac{n+1}{2})+1$；

#### 查找

与二叉查找树类似，不同的是根据关键词的大小、可选择的子树不止2棵；

首先在B树上查找结点（在磁盘上进行），并在结点内查找关键字（在内存上运行），找到后则查找成功，找不到则根据对应的指针在子树上继续寻找；

如果查到叶子结点（即空指针），则说明查找失败；

#### 插入

插入后，为保证B树满足定义，可能需要进行分裂操作；

对于一棵$m$阶的B树，每个结点的关键字个数为$n\in[\lceil m/2\rceil-1,m-1]$，因此

​	如果插入后结点关键字$<m$​，则直接插入即可；

​	如果插入后结点关键字$\geqslant m$​​，则原结点从中间位置分裂为两个结点，并且父结点新增一个关键字（倘若父结点新增关键字后导致父结点关键字个数$\geqslant m$​，则父结点继续分裂，依次往上）；

#### 删除

删除后，为保证B树满足定义，可能需要进行合并操作；

对于一棵$m$阶的B树，每个结点的关键字个数为$n\in[\lceil m/2\rceil-1,m-1]$​，因此：

​	(1) 如果要删除的关键字$k$​不在最底层非叶子结点（不在叶子节点的上面一层），

​		若小于$k$的子树中关键字数目$>\lceil m/2\rceil-1$，则用前驱值$k'$取代$k$，再递归删除$k'$；

​		若大于$k$的子树中关键字数目$>\lceil m/2\rceil-1$，则用后继值$k'$取代$k$，再递归删除$k'$；

​		若前后两个子树中关键字数目均$>\lceil m/2\rceil-1$，则将两个子结点合并，直接删除$k$即可；

​	(2) 如果要删除的关键字在最底层非叶子结点，

​		若$k$所在结点的关键字数目$>\lceil m/2\rceil-1$，则直接删除$k$即可；

​		若$k$所在结点的关键字数目$=\lceil m/2\rceil-1$，且与其相邻的左/右结点关键字数目$\geqslant\lceil m/2\rceil$，则从左/右结点借一个关键字到父结点，父结点的关键字取代$k$，然后删除$k$；

​		若$k$​所在结点的关键字数目$=\lceil m/2\rceil-1$​，且与其相邻的左/右结点关键字数目也$=\lceil m/2\rceil$​，则无法借关键字，此时删除关键字并将父结点的关键字与左/右结点的关键字合并​；



### 2. B+树

B+树应数据库的需要而出现；

与$B$树的差异：

​	(1) B+树中，具有$n$个关键字的结点有$n$个子树，即每个关键字对应一个子树；而在B树中，具有$n$个关键字的结点有$n+1$个子树；

​	(2) B+树中，每个结点的关键字范围是$[\lceil m/2\rceil,m]$；而在B树中，每个结点的关键字范围是$[\lceil m/2\rceil-1,m-1]$；

​	(3) B+树中，叶子结点包含全部关键字；

B+树可以进行两种查找运算：从最小关键字开始的顺序查找，从根结点开始的多路查找；

B+树的查找、插入、删除与B树类似，只是在查找关键字时，B树找到相等的便终止，B+树即使找到相等的也要继续向下查找到叶子结点；因此B+树的查找，无论是否成功，都是从根结点到叶子结点的路径；



Tips：

- B树的叶子节点对应查找失败的情况，因此$n$个关键字就有$n+1$个叶子节点；
- 含有$n$个非叶子结点的$m$阶$B$树至少包含的关键字个数为$(n-1)(\lceil m/2\rceil-1)+1$；
- B+树支持顺序查找而B树不支持；
- B+树相比$B$树，更适合与实际应用中操作系统的文件索引和数据库索引，因为其磁盘读写更低，效率更加稳定



## IV. 散列表

### 1. 基本概念

**散列函数** - 把查找表中的关键字映射成该关键字对应的地址的函数；

**冲突** - 不同的关键字被映射到同一地址；

**散列表** - 根据关键字直接进行访问的数据结构；

​	理想情况下（无冲突），散列表查询操作的时间复杂度为$O(1)$​；

**同义词** - 能够得到相同地址的不同关键字；

### 2. 构造方法

#### 原则

(1) 散列函数的定义域应覆盖所有关键字，值域的范围依赖散列表的地址范围；

(2) 运算结果应当等概率、均匀地分布在整个地址空间；

(3) 越简单越好；

#### 常见方法

|            | 解释                                                         | 优点                               | 缺点                                             |
| ---------- | ------------------------------------------------------------ | ---------------------------------- | ------------------------------------------------ |
| 直接定址法 | 直接取关键字的某个线性函数值为地址<br />$H=a \times key + b$ | 简单，不会有冲突，适合连续的关键字 | 如果关键字不连续，则地址分散，造成存储空间的浪费 |
| 除留余数法 | 找一个接近但不大于散列表表长的数作为除数<br />$H=key\%p$     | 简单                               | 除数选的不好容易产生冲突                         |
| 数字分析法 | 分析关键字的分布概率，适合已知所有关键字的情况               | /                                  | /                                                |
| 折叠法     | 将关键字分割成位数相同的几部分，相加作为地址，适合位数较多的关键字 | /                                  | /                                                |

### 3. 冲突处理

#### 开放定址法

指可存放新表项的空闲地址既对同义词开放，也对非同义词开放；

数学递推公式为：
$$
H_i=(H(key)+d_i)\%m
$$
根据$d_i$取值的不同，可细分为以下：

(1) 线性探测法

​	$d_i=0,1,2,...,m-1$；

​	当遇到冲突时，顺序查看表中的下一个单元（如果位于表的末尾，下一个是表的开头），直到找到一个空闲表项；

​	优点：简单；

​	缺点：效率低，容易引起聚集堆积现象；

(2) 平方探测法(二次探测法)

​	$d_i=0^2,1^2,2^2,...,k^2,k\leqslant \frac{m}{2}$​；

​	列表长度$m$需要能表示成$4k+3$​的素数；

​	优点：可以有效避免元素堆积；

​	缺点：不能探测到散列表上所有单元，但至少能探测到一半；

(3) 再散列法

​	再用另一个函数散列一次；

(4) 随机法

​	$d_i$取随机数；



#### 链接法

将同义词存储在一个线性链表中，该链表由散列地址唯一标识；

适用于经常插入和删除的情况；



### 4. 散列查找

查找步骤：

​	根据查找关键字与散列函数得到地址，在线性表中访问该地址，

​		① 如果该地址没有值，则查找失败；

​		② 如果该地址有值，且与关键字相等，则查找成功；

​		③ 如果该地址有值，但与关键字不相等，则根据给定的冲突解决方法继续访问下一个地址进行比较；

#### 效率

散列表的查找效率取决于三个因素：① 散列函数 ② 冲突处理方法 ③ **装填因子**；

装填因子$\alpha$表示一个表的装满程度，设表长为$m$，表中元素数为$n$，则$\alpha=\frac{n}{m}$；

散列表的平均查找长度依赖于装填因子$\alpha$；



## V. 串

由零个或多个字符组成的有限序列；

### 1. 存储结构

定长顺序存储、堆分配存储、块链存储（块的大小不确定）；

### 2. 模式匹配

指求字串在主串中位置的操作；

#### 简单模式匹配

分别用两个指针$i$$和j$表示主串和子串中字符的位置，两者进行比较，如果相等则继续比较下一个字符，如果不相等则子串从头开始、主串回溯为上一次开始的位置之后一位进行比较；

假设主串和子串长度分别为$m,n$，则最差情况下时间复杂度为$O(nm)$；

```c++
int SimpleStringMatch(const std::string &main, const std::string &sub)
{
	int i = 0;
	int j = 0;
	int k = 0;
	while ((i < main.size()) && (j < sub.size()))
	{
		if (main[i] == sub[j])
		{
			i++;
			j++;
		}
		else
		{
			k++;
			i = k;
			j = 0;
		}
	}
	if (j == sub.size())
		return k;
	else
		return -1;
}
```

#### KMP模式匹配

简单模式匹配中，每次字符不相等，主串都要回溯，其中很多字符都是已经比较过的，因此造成不必要的浪费；

KMP算法利用比较过的信息，指针$i$​不需要回溯，只需要将子串向后移动到一个合适的位置，再和主串进行比较即可；

**前缀**

字符串中除最后一个字符外的所有子串；

如$ababa$的前缀为$a,ab,aba,abab$；

**后缀**

字符串中除第一个字符外的所有子串；

如$ababa$的后缀为$a,ba,aba,baba$；

**部分匹配值**

指字符串的所有前缀和所有后缀中的最长相等子串的长度；

如$ababa$​的部分匹配值为$00123$​；



KMP模式匹配在循环过程中，借助部分匹配值，完成对子串的后移；

KMP算法的时间复杂度为$O(n+m)$；



**$next$​​​数组**

规定：$next[1]=0,next[2]=1$；

设当前求的是$next[n](n>2)$，且$next[n-1]=m$；

① 若串的前$m$个字符和后$m$个字符相等，则$next[n]=m+1$；

② 若串的前$m$个字符与后$m$个字符不相等，

​	若$m=1$，则$next[n]=1$；

​	若$m \neq 1$，则令$m = m-1$，比较串的前$m$个字符和后$m$个字符，若相等，则进行步骤①，若不相等，则进入步骤②；



# 七、排序

## I. 相关概念

**稳定性**

若待排序表中有两个元素$R_i$与$R_j$，其对应关键字$k_i=k_j$​，若在排序前后$R_i$和$R_j$​​的相对顺序不变，则称该排序算法是稳定的；否则是不稳定的；

**内部、外部排序**

内部排序 - 在排序期间全部元素都存放在内存中的排序；

外部排序 - 在排序期间元素无法全部存放在内存中，需要在内存内外之间移动的排序；



## II. 插入排序

### 1. 直接插入排序

适合元素基本有序且数据量不大的情况，此时直接插入排序的效率最高；

对于$n$个元素，最好情况下比较次数为$n-1$，最差情况下比较次数为$\frac{n(n-1)}{2}$​；

### 2. 折半插入排序

相比直接插入排序，较少了元素比较次数，元素移动次数没有减少；

虽然时间复杂度都是$O(n^2)$​，但当数据量较小时，折半插入排序有更高的性能；

### 3. 希尔排序

又称缩小增量排序；

对于数据$a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9$，如取增量为$3$，则分组为$\{a_1,a_4,a_7\},\{a_2,a_5,a_8\},\{a_3,a_6,a_9\}$，通过逐渐减小增量到$1$，使得元素逐渐趋于有序；

希尔排序的组内排序采用的是直接插入排序；

|              | 解释                                                         | 复杂度   | 稳定性 | 适用性             |
| ------------ | ------------------------------------------------------------ | -------- | ------ | ------------------ |
| 直接插入排序 | 前$i$个元素有序，后$n-i$个元素无序；<br />取第$i$个元素，与有序元素逐个比较并插入到合适的位置，$i++$； | $O(n^2)$ | 稳定   | 顺序存储和链式存储 |
| 折半插入排序 | 相比直接插入排序，其插入过程是通过折半查找实现的；           | $O(n^2)$ | 稳定   | 仅限顺序存储       |
| 希尔排序     | 先将全部元素分为多个小组，每个小组分别排序后，得到一个局部有序的表，再对全部元素进行排序； | $O(n^2)$ | 不稳定 | 仅限顺序存储       |



## III. 交换排序

### 1. 冒泡排序

通过两两比较元素并视结果进行交换；

每趟排序得到一个当前表内最小元素并剔除出表，即会将一个元素放到其最终位置上；

对于$n$个元素，需要$n-1$趟冒泡，最多比较次数为$\frac{n(n-1)}{2}$；

### 2. 快速排序

采用分治法+递归；

每趟排序后会将比较的基准元素放到其最终位置上；

快速排序平均情况下的运行时间与最佳情况类似，因此是内部排序算法中平均性能最佳的排序算法；

递归次数与各元素的初始排序有关，与处理顺序无关；最好情况下递归深度为$\log_2n$，最差情况下递归深度为$n$​；

最佳情况：每次的基准元素将表分为两个长度相等的子表；

最差情况：表本身有序或逆序；

|          | 解释                  | 复杂度   | 稳定性 |
| -------- | --------------------- | -------- | ------ |
| 冒泡排序 | $n-1$趟两两排序并交换 | $O(n^2)$ | 稳定   |
| 快速排序 | 分治法                | $O(n^2)$ | 不稳定 |



## IV. 选择排序

### 1. 简单选择排序

每次从$n$​个元素中挑选出一个最小的元素，执行$n-1$​次后可以得到一个有序的表；

选择排序法的比较次数与序列初始状态无关，始终为$\frac{n(n-1)}{2}$；

### 2. 堆排序

将$n$​个元素视为一棵完全二叉树，利用完全二叉树中结点之间的关系，挑选出最小元素；

完全二叉树性质：

​	如果一个结点为$i$​，则其父结点为$\lfloor i/2 \rfloor$​，两个子结点分别为$2i$​和$2i+1$​；​

当$n$个关键字序列满足：

​	① $L(i) \leqslant L(2i)$，$L(i) \leqslant L(2i+1)$​，即根结点小于子结点，称为小根堆，最小的元素位于根结点；

​	② $L(i) \geqslant L(2i)$，$L(i) \geqslant L(2i+1)$，即根结点大于子结点，称为大根堆，最大的元素位于根结点；

构造初始堆：

​	step 1：按照层序遍历的方式将数组的元素填入完全二叉树中；

​	step 2：设完全二叉树的高度为$h$，从$h-1$​层开始进行反复筛选，从二叉树的最后一个非叶子结点开始，即$\lfloor n/2 \rfloor$；

​	step 3：按照$i$逐步减小的顺序进行heapify操作，直到$i$​等于1；



得到初始堆之后（假设得到的是大根堆），则可以确定根结点为最大值，将根结点与最后一个结点交换并剔除根结点，此时数的heap性被打乱，需要重新构造，依此类推得到每一个最大值；



Tips：

- 对于小根堆，最小的元素位于根结点，最大的元素一定位于叶子结点，若元素个数为$n$，则最后一个非叶子结点为$\lfloor n/2 \rfloor$，则最大的元素位于$\lfloor n/2 \rfloor +1$到$n$​之间；对于大根堆求最小元素亦是如此；
- 进行一次向上调整操作，最多需要的比较次数为$\lfloor \log_2n \rfloor$，每次往堆中插入或删除一个元素都需要进行一次向上调整操作，因此，堆的插入和删除的时间复杂度为$O(\log_2n)$；
- 构建一次初始堆的时间复杂度为$O(n)$​，堆排序的时间复杂度为$O(n\log_2n)$；



|              | 解释                     | 复杂度        | 稳定性 |
| ------------ | ------------------------ | ------------- | ------ |
| 简单选择排序 | $n-1$趟挑选              | $O(n^2)$      | 不稳定 |
| 堆排序       | 利用完全二叉树的性质排序 | $O(n\log_2n)$ | 不稳定 |

## V. 归并与基数

### 1. 归并排序

**归并** - 将两个或两个以上的有序表合并成一个新的有序表；

**2路归并排序** - 对于一个$n$个元素的表：

​	① 将其看作$n$​个长度为1的有序表，两两归并，得到$\lceil n/2\rceil$个长度为2或1的有序表；

​	② 继续两两合并，直到得到一个长度为$n$的有序表；

一般来说，对于$N$个元素进行$k$路归并排序，需要的趟数为$m=\lceil \log_kN \rceil$​；



### 2. 基数排序

不涉及关键字之间的比较，通过对比关键字的位数来排序；

分为最高位优先排序(MSD)和最低位优先排序(LSD)；

以LSD为例，准备0-9共十个桶，假设排序表中最大元素的位数是3：

​	① 将排序表中所有元素补位为3位（高位补0）；

​	② 按照个位数的大小，分别放入十个桶中，再从桶中取出（同一个桶中的先入先出），得到新的排序表；

​	③ 按照步骤②依次对比十位数和百位数，最终得到有序表；



|                 | 解释                     | 复杂度                                    | 稳定性 |
| --------------- | ------------------------ | ----------------------------------------- | ------ |
| 归并排序（2路） | 将有序表合并为新的有序表 | $O(n\log_2n)$                             | 稳定   |
| 基数排序        | 不需要比较关键字         | $O(d(n+r))$，$d$为最大位数，$r$为桶的个数 | 稳定   |



Tips：

- 归并排序与选择排序的比较次数与序列的初始状态无关；

- 对于极大量的数据，通常采用外部排序中的归并排序；

- 使用归并排序合并两个元素个数为$N$的表，

  当一个表中的最小元素都大于另一个表中的最大元素时，比较次数最少，为$N-1$；

  当两个表中的元素依次间隔时，比较次数最多，为$2N-1$；



## VI. 内部排序算法的比较

|          |               | 时间复杂度         |          | 空间复杂度   | 稳定性 |
| -------- | ------------- | ------------------ | -------- | ------------ | ------ |
|          | 最好          | 平均               | 最差     | 平均         |        |
| 直接插入 | $O(n)$        | $O(n^2)$           | $O(n^2)$ | $O(1)$       | 稳定   |
| 冒泡     | $O(n)$        | $O(n^2)$           | $O(n^2)$ | $O(1)$       | 稳定   |
| 简单选择 |               | 均为$O(n^2)$       |          | $O(1)$       | 不稳定 |
| 希尔     |               | 取决于所选择的增量 |          | $O(1)$       | 不稳定 |
| 快速     | $O(n\log_2n)$ | $O(n\log_2n)$      | $O(n^2)$ | $O(\log_2n)$ | 不稳定 |
| 堆       |               | 均为$O(n\log_2n)$  |          | $O(1)$       | 不稳定 |
| 2路归并  |               | 均为$O(n\log_2n)$  |          | $O(n)$       | 稳定   |
| 基数     |               | 均为$O(d(n+r))$    |          | $O(r)$       | 稳定   |

空间复杂度与序列初始状态无关的有：简单选择、堆、归并、基数；

从需要的辅助空间的大小来看，归并 > 基数 > 快速 > 其他；

能够每趟排序至少确定一个元素最终位置的有：冒泡、简单选择、快速、堆；

顺序表与链式表都支持的有：直接插入、选择、冒泡；只支持顺序表的有折半插入、希尔、堆；



若元素个数较小，且已经基本有序，则适合使用直接插入或冒泡；

若元素个数较多，应使用复杂度为$O(n\log_2n)$的算法，如快速排序、堆排序、归并排序，其中只有归并排序是稳定的；

若元素个数较多，且关键字为实数+位数较少时，适合使用基数排序；

若元素的个数非常多，适合使用希尔排序或归并排序；



## VII. 外部排序

外部存储 - 由于要排序的文件过大，需要将文件存储在外存，排序时再一部分一部分地调入内存中进行排序，期间需要多次内、外存之间的数据传输；

外部存储通常使用归并排序：

​	① 将外存内数量为$n$的文件分为等长的、长度为$h$的子文件，依次将子文件载入内存中，使用相应的内部排序方法进行排序，再将得到的有序子文件写回外存中，称为**归并段**；

​	② 对归并段再进行归并排序，得到整个有序的文件；

提高外部归并排序的速度：(1) 增加归并路数； (2) 减少归并段的个数；
