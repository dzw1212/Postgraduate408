# 一、基本概念

## I. 数据结构

### 1. 三要素

**数据的逻辑结构**，如

​	集合：两个数据元素同属于一个集合；

​	线性结构：数据元素之间存在一对一的关系；

​	树形结构：数据元素之间存在一对多的关系；

**数据的存储结构**，如

​	顺序存储：逻辑上相邻的元素的物理存储位置也是相邻的；

​		优点 - 可以随机存取，每个元素占用最少的存储空间；

​		缺点：只能使用一整块内存，可能产生较多的内存碎片；

​	链式存储：存储位置不一定相邻，借助指针表示元素之间的逻辑关系；

​		优点：充分利用存储空间，不会产生内存碎片；

​		缺点：指针额外消耗内存空间，只能顺序存取而不能随机存取；

​	索引存储：存储的同时建立附加的索引表，记录元素的地址；

​		优点：搜索效率高；

​		缺点：增删速度需要修改索引表，因此效率低；索引表额外消耗内存空间；

​	散列存储：即哈希存储，根据元素关键字直接计算出存储地址；

​		优点：增删改查效率都高；

​		缺点：可能会产生存储位置冲突的问题，解决冲突问题额外消耗时间；

**数据的运算**



## II. 算法

### 1. 效率的度量

#### 时间复杂度

一个语句的频度是指该语句被重复执行的次数，一个算法中所有语句的频度之和称为总频度，总频度的数量级称为算法的**时间复杂度**，记为$T(n)$；

一个算法中最深层的循环内的语句的频度$f(n)$与$T(n)$同一数量级，因此常用$f(n)$分析时间复杂度；
$$
T(n)=O(f(n))
$$
一般情况考虑的是最坏情况下的时间复杂度，以保证算法的运行时间不会超出这个值；

##### 常见比较

$$
O(1)<O(\log_2n)<O(n)<O(n\log_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
$$

##### 运算规则

$$
O(f(n))+O(g(n))=O(max(f(n),g(n)))\\
O(f(n))\times O(g(n))=O(f(n)\times g(n))
$$

#### 空间复杂度

表示一个算法耗费的存储空间，记作$S(n)$；
$$
S(n)=O(g(n))
$$


# 二、线性表

## I. 定义

线性表是具有相同数据类型的$n$个数据元素的有限序列，表示数据元素之间前后排列的线性逻辑结构；

## II. 顺序表实现

顺序表使用一组地址连续的存储单元依次存储线性表中的数据，使得逻辑结构相邻的元素在物理结构上也相邻；

### 1. 静态分配与动态分配

静态分配：定义线性表时就设置好数组的长度，使用时无法改变；

```C
#define MAX_SIZE = 100
typedef struct
{
    ElemType data[MAX_SIZE];
    int length;
}ExamList;
```

动态分配：定义线性表时只填写元素的指针，运行时再设置数组的长度；

```c
typedef struct
{
    ElemType *data;
    int length;
}ExamList;

data = (ElemType *)malloc(sizeof(ElemType) * nListLength);
```

### 2. 特点

支持随机访问，可以通过下标在$O(1)$的时间复杂度内找到对应的元素；

存储密度高；

插入和删除时需要移动大量的元素，效率低；

### 3. 时间复杂度

| 操作       | 时间复杂度                           |
| ---------- | ------------------------------------ |
| 插入       | $O(n)$                               |
| 删除       | $O(n)$                               |
| 按值查找   | $O(n)$（无序），$O(\log_2n)$（有序） |
| 按下标查找 | $O(1)$                               |

## III. 链表实现

每个节点中除了保存元素本身的信息外，还需要一个指向下一个节点的指针，来建立元素之间的线性关系；

### 1. 单链表

#### 1. 头指针与头结点

使用头指针和头结点来标识一个链表，头指针一般指向头结点，当头指针指向`null`时，表示头结点不存在，即该链表不存在；

```c
typedef struct LNode
{
    ElemType data;
    struct LNode *next;
}LNode, *List;
```

#### 2. 时间复杂度

| 操作                                  | 时间复杂度 |
| ------------------------------------- | ---------- |
| 根据下标，插入/删除元素               | $O(n)$     |
| 已知结点，在其之前或之后插入/删除元素 | $O(1)$     |
| 根据下标查找                          | $O(n)$     |

### 2. 分类

|              | 特点                                                         |
| ------------ | ------------------------------------------------------------ |
| 单链表       | 只有一个指向下一个结点的`next`指针，因此只能从头开始依次向后遍历； |
| 双向链表     | 有指针`prior`指向上一个结点和指针`next`指向下一个结点；      |
| 单向循环链表 | 将尾结点的`next`指针指向头结点，从而形成一个循环；           |
| 双向循环链表 | 不仅将尾结点的`next`指针指向头结点，还要将头指针的`prior`指针指向尾结点； |

## IV. 两种实现的比较

若需要频繁的查找，选择线性表实现；

若需要频繁的插入删除，则选择链表实现；



# 三、栈与队列

## I. 栈

栈 --- 只能在一端进行插入或删除操作的线性表；

LIFO（后进先出）；

