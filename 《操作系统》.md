# 一、概述

## I. 特征

**并发** - 多个事件在同一事件间隔（并非同一时刻）内发生；

​			并行 - 多个事件在同一时刻内同时发生；

**共享** - 多个进程可以访问同一资源；

​			互斥共享 - 资源同一时刻只能由一个进程访问；

​			同时访问 - 资源同一时刻可以让多个进程同时访问；

**虚拟** - 将物理的实体变成逻辑上的对应物体；

​			虚拟处理器 - 时分复用技术；

​			虚拟存储器 - 空分复用技术；

**异步** - 进程的执行并非一镜到底，而是走走停停，以不可预知的速度向前推进；

​			简而言之，同步 - 被其他程序占用CPU时，阻塞等待其他程序执行完成；

​								异步 - 与其他程序一起分时占用CPU；

​			异步与并发两个概念并不绑定，使用同步也可以实现并发；

## II. 目的

方便用户使用硬件与配套软件，提供功能接口，提高资源的利用率；

## III. 分类

**分时操作系统**

​	分时技术 - 将处理器的运行时间分割成很短的时间片，将时间片分给各个进程使用；

​	分时操作系统 - 多个用户通过终端同时共享一台主机，每个用户与主机的交互不受其他用户的干扰，主机的响应时间适中；

**实时操作系统**

​	硬实时 - 对主机的相应时间有严格的、极短的时间要求；

​	软实时 - 对主机的相应时间有要求，但偶尔超时也可以接受；

**网络操作系统**

​	利用网络，实现多台计算机之间的通信；

**分布式操作系统**

​	没有主机和从机的区分，每台计算机都能为其他计算机所用；

**个人操作系统**

​	PC，满足工作及娱乐需求，无需多言；

**库操作系统**

​	将系统服务作为运行库链接到用户程序上，解决微内核架构中用户态与内核态频繁切换的问题；

## IV. 运行环境

**内核态与用户态**

​	CPU执行的程序分为两种，**系统内核程序**和**用户自定义程序**；

​	系统内核程序相比于用户自定义程序，拥有更高的权限，可以执行计算机内部的特权指令（如IO指令，中断指令等），在执行系统内核程序时，CPU会切换到内核态；

​	内核的功能：

​	① 时钟管理 - 计时器、分时系统；

​	② 中断机制

​	③ 原语 - 操作系统底层的公用小程序，具有以下特征：

​					(1) 位于操作系统最底层，最接近硬件；

​					(2) 具有原子性（关闭中断，执行完成后，再打开中断）；

​					(3) 运行时间短，调用频繁；

​	④ 系统数据管理 - 如进程管理、存储器管理、设备管理；

**中断和异常**

​	用户态下需要一些“门”，用来进入内核态，这些“门”即为中断和异常；

​	中断（Interrupt）：来自CPU指令之外的事件的发生，目的是提供计算机资源的利用率；

​	异常（Exception）：也称内中断，无法被屏蔽；

​	遇到中断或异常后CPU会立即进入内核态进行处理，该功能由硬件寄存器实现；

**系统调用**

​	指操作系统为用户提供的一系列特殊子程序，控制操作系统中的各种共享资源，用户若想使用这些资源，需要通过系统调用让操作系统代为完成；

​	系统调用的功能大致包括：

​		设备管理、文件管理、进程控制、进程调用、内存管理；

​	目的：防止用户随意修改重要的系统资源，防止影响到其他用户，维护系统的稳定；

**访管指令**

​	也称陷入指令、trap指令；

​	用户程序可以通过调用访管指令，产生访管中断，将操作系统将用户态切换为内核态，从而执行特殊指令；

## V. 体系结构

|        | 说明                                                         | 优点                     | 缺点                                                         |
| ------ | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| 大内核 | 将操作系统的主要功能模块作为一个紧密联系的整体放入内核态中，从而提供高性能的服务 | 模块之间共享信息，性能高 | 随着规模的扩大，功能越来越复杂，模块层次之间也越来越耦合，难以维护 |
| 微内核 | 将最基础的功能保留在内核态，将其他非必须的功能分离出去       | 接口清晰，易于维护       | 需要频繁在用户态和内核态之间切换，性能低（但其实没低多少，利大于弊） |



# 二、进程管理

## I. 进程

### 1. 概念

使用进程来描述和控制程序的并发执行，实现操作系统的并发新和共享性；

进程具有专用的数据结构，称之为进程控制块（Process Control Block），用于描述进程的基本信息和运行情况，PCB是进程存在的唯一标志；

进程映像(进程实体) = 程序段 + 相关数据段 + PCB；

进程是动态的，但是进程映像是静态的，进程是进程印象的运行过程，是系统进行资源分配和调度的独立单位；

### 2. 状态

处于生命周期内的进程一般可分为五种状态：

(1) 运行态 (2) 就绪态 (3) 阻塞态 (4) 创建态 (5) 终止态 

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210819195556750.png" alt="image-20210819195556750" style="zoom:50%;" />

### 3. 控制

(1) **创建新进程**

​	① 为新进程分配一个唯一的进程号，并申请一个空白的PCB；

​	② 为新进程分配资源，为新进程的程序数据与用户栈分配内存空间；

​	③ 初始化PCB；

​	④ 将新进程插入进程就绪队列，等待调度运行；

(2) **终止进程**

​	① 根据标识符找到对应进程的PCB，查询进程当前状态；

​	② 若当前状态为运行态，则立即终止运行；

​	③ 终止该进程的所有子进程；

​	④ 将该进程所占用的资源归还给其父进程或者操作系统；

​	⑤ 将该进程的PCB删除；

(3) **阻塞进程**

​	① 找到PCB，查询当前状态；

​	② 若当前状态为运行态，则停止运行并保护现场，将进程转为阻塞态；

​	③ 将PCB插入等待队列；

(4) **唤醒进程**

​	①在等待队列中找到PCB；

​	② 将进程PCB移出等待队列，设置状态为就绪态；

​	③ 将PCB插入就绪队列；

(5) **进程切换**

​	① 保护上下文；

​	② 更新PCB并插入对应队列；

​	③ 执行另一个进程并更新其PCB；

​	④ 更新环境与内存数据；

*PS: CPU时间片对进程的调度不涉及进程切换*

### 4. 组成

进程映像由三部分组成，PCB + 程序段 + 数据段；

(1) 程序控制块 PCB

​	为方便对各个进程进行管理，需要用某种方式将处于同一状态的进程组织起来；

​	目前常用的管理方式有索引（插入索引表中）和链接（插入队列中）两种；

(2) 程序段

​	即进程运行过程中能够运行到的程序代码段；

(3) 数据段

​	进程运行过程中产生或依赖的数据；

### 5. 通信

低级通信 ：

​	信号量（PV操作）；

高级通信（以较高的效率传输大量数据）：

​	管道（命名/无名）；

​	消息队列；

​	共享内存；

## II. 线程

### 1. 概念

相当于轻量级的进程，是程序执行与系统调度的最小单元；

线程自身不拥有系统资源，只拥有用于运行的必不可少的一点资源，与同一进程下的其他线程共享全部资源；

进程内部的线程切换只消耗很少的时空开销；

### 2. 目的

减小程序在并发过程中的（进程切换造成的）开销，进一步提高并发性能；

### 3. 组成

包括线程ID，程序计数器、寄存器集合、堆栈等；

### 4. 实现方式

可分为**用户级线程（ULT）**和**内核级线程（KLT）**；

用户级线程ULT：

​	线程的管理由进程完成，因为进程之间不可共享资源，因此每个进程都维护一个包含其下所有线程信息的线程表；

​	内核意识不到线程的存在；

内核级线程KLT：

​	线程的管理工作由内核完成，内核维护一个包含所有线程（包括不同进程的线程）信息的线程表；

​	对线程的管理通过系统调用完成；

|                     | 优点           | 缺点                         |
| ------------------- | -------------- | ---------------------------- |
| User Level Thread   | 避免了切换开销 | 无法跨进程调度线程           |
| Kernel Level Thread | 存在切换开销   | 可以通过系统调用调度所有线程 |



ULT 和 KLT可以组合使用，由此产生了多线程模型：

|            | 说明                                          | 优点                                           | 缺点                                                         |
| ---------- | --------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 多对一模型 | 多个ULT映射到一个KLT                          | 线程管理由用户空间完成，效率高                 | 只有一个内核级线程，如果一个用户级线程在使用内核服务时阻塞，则整个进程都会阻塞 |
| 一对一模型 | 一个ULT对应一个KLT                            | 一个线程阻塞后允许另一个线程继续执行，并发性强 | 每创建一个用户级线程都需要一个对应的内核级线程，创建现成的开销大 |
| 多对多模型 | $n$个ULT映射到$m$个KLT上，要求$n \geqslant m$ | 集两家之所长                                   | 较复杂                                                       |

## III. 处理机调度

调度 - 由于进程的数量往往多于处理机的数量，因此需要使用一定的算法对处理机进行分配，从而使进程并发执行；

### 1. 调度层次

一次作业从提交到开始执行，一般需要经过三个级别的调度：

(1) **作业调度**

​	按照一定的原则从外存中处于后备状态的作业中挑选一个或多个，为其分配内存等必要资源；

​	作业调度的执行频率低，一般几分钟一次；

(2) **内存调度**

​	将暂时不能运行的进程调出至外存中等待（阻塞态），将外存中已具备运行条件的进程调入至内存中（就绪态）；

(3) **进程调度**

​	从就绪队列中选择进程，将处理机分配给该进程；

​	进程调度的频率很高，一般为几十毫秒一次；

​	进程调度是最基础的，所有的操作系统中都配备有进程调度；

### 2. 调度条件

在发生的引起进程调度的因素后，不一定能马上进行调度操作，比如

​	① 处理中断的过程中；

​	② 执行加锁的代码段时；

​	③ 其他屏蔽中断的原子操作过程中；

能够立即进行调度的情况：

​	① 发生引起调度的因素并且当前进程无法继续运行；

​	② 中断处理结束后、返回中断现场前；

### 3. 调度方式

**非剥夺式调度**

当一个进程正在执行时，即使有某个更为重要的进程$A$进入就绪队列，仍然等待当前进程继续执行直到完成或进入阻塞态，再将处理机分配给进程$A$；

简单、系统开销小，但不能用于分时系统或实时系统（等待时间太长/不确定）；

**剥夺式调度**

当一次进程正在执行时，若有某个更为重要的进程$B$进入就绪队列，则立即终止原进程的运行，将处理机分配给进程$B$；

剥夺式调度有助于提高系统吞吐率和响应效率，但剥夺需要遵守优先权、短进程优先等原则；

### 4. 调度算法评价准则

(1) CPU利用率 - 尽可能使CPU保持繁忙；

(2) 吞吐率 - 单位时间内CPU完成作业的数量；

(3) 周转时间 - 从作业提交到作业完成的时间；

(4) 进程等待被处理机执行的时间；

(5) 响应时间；

### 5. 典型调用算法

|                      | 说明                                                         | 优点                                       | 缺点                                       |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------ | ------------------------------------------ |
| 先来先服务算法FCFS   | 先排队的先调度；<br />可用于作业调度也可以用于进程调度；<br />属于非剥夺式算法； | 简单                                       | 效率低；<br />对长作业有利，对短作业不利； |
| 短优先算法SJF        | 短的作业/进程优先被调度；<br />可用于作业调度也可以用于进程调度； | 平均等待时间最少                           | 对长作业极度不利；                         |
| 优先级调度算法       | 优先级高的作业/进程优先被调度；<br />可用于作业调度也可以用于进程调度； | /                                          | /                                          |
| 高响应比优先调度算法 | 一般用于作业调度；<br />计算每个作业的相应比，相应比高的优先被调度；<br />相应比=(等待时间+需要的服务时间)/需要的服务时间； | 兼顾了短作业和长作业                       | /                                          |
| 时间片轮转调度       | 规定每个时间片的时长，超过时长后无论是否完成都必须移交处理机使用权； | 没有偏好一视同仁，多个用户能够得到及时响应 |                                            |
| 多级反馈队列调度算法 | 设置多个优先级与时间片时长不同的队列                         | 兼顾多方面评价准则                         |                                            |

## IV. 进程同步

### 1. 基本概念

**临界资源**

指一次仅允许一个进程使用的资源；

进程中，对临界资源进行访问的代码段称为临界区；

**同步**

由于进程之间是异步并发执行的，因此程序之间执行完成的先后顺序不一定，需要引入同步，使进程之间具有先后顺序；

又称为直接制约关系，源于进程之间的相互合作，规定当一方达成某种条件时另一方执行某种操作；

**互斥**

也称间接制约关系，源于临界资源的互斥共享属性；

### 2. 临界区互斥的实现

#### (1) 原则

① **空闲让进**；

② **忙则等待**；

③ **有限等待** - 对请求访问临界区的进程，应保证其在有限时间内能够进入临界区；

④ **让权等待** - 当进程不能进入临界区时，应立即释放处理机；

#### (2) 软件实现

① 单标志法

​	设置一个整型标志位，用于指示能够进入该临界区的进程的PID，该进程进入临界区完成操作离开时，需要将标志位设为下一个允许进入的进程的PID；

​	假如一直没有对应PID的进程进入临界区，则没有进程可以进入临界区，造成资源的浪费；

② 双标志先检查法

​	检测其他进程是否进入临界区，若已有进程进入临界区则等待，若没有则进入临界区并将自身标志位置为true；

​	由于检测与置位并非原子过程，所以可能多个进程同时进入临界区；

③ 双标志后检查法

④ Pterson's Algorithm

#### (3) 硬件实现

① 中断屏蔽法

② 硬件指令法



### 3. 信号量

进程之间共享一个公共信号量，用于解决同步和互斥问题；

**结构**

一个整型变量，用来表示该临界区资源可同时被访问的进程的个数；

一个链表，用来表示所有等待该资源的进程；

**操作**

```c++
//阻塞所有线程
Block();

//唤醒某个线程
Wakeup();

//P操作 - 请求一个资源
void wait(sem S)
{
    S.value--;
    if (S.value < 0)
    {
        add P to S.L;
        Block(S.L);
    }
}

//V操作 - 释放一个资源
void signal(sem S)
{
    S.value++;
    if (S.value <= 0)
    {
        remove P from S.L;
        Wakeup(P);
    }
}
```

### 4. 管程

管程是一组数据及定义在这组数据上的对其进行操作的软件模块，这些操作能管理管程中的数据和同步进程；

管程实质是一个对软硬件资源抽象化后形成的抽象类，其具有以下特点：

​	① 局部于管程的数据只能被管程内部的方法所访问（私有成员）；

​	② 进程只允许通过调用管程内部的方法来访问共享数据；

​	③ 每次只允许一个进程执行管程内部的方法；

由于管程是一种语言语法要求，因此其同步互斥完全由编译器保证，无序调用操作系统的接口；



## V. 死锁

死锁 - 多个进程因为竞争资源而造成互相等待的僵局；

### I. 必要条件

(1) 互斥

​	资源具有排他性，同一时间只能由一个进程访问；

(2) 不剥夺

​	资源在被一个进程占用时，其他进程无法抢夺；

(3) 请求并保持

​	在自身占用一个资源的情况下，请求占用其他资源；

(4) 循环等待

​	进程与进程之间对资源的占用与请求占用形成一个环，称为资源分配图中含有环；

​	资源分配成环但不一定有死锁的原因是同类资源的数量大于1，如果同类资源只有1个，则循环等待是死锁的充分必要条件；

### II. 解决死锁

**预防死锁(设计阶段)**

预防死锁，只需要破坏形成死锁的四个条件中的一个即可；

**避免死锁(分配阶段)**

(1) 系统安全状态

​	找到一个合理的资源分配序列，按照这个序列分配资源则系统是安全的；否则称系统是不安全的；

(2) 银行家算法

​	当现有资源无法满足进程的请求时，推迟分配；

**死锁定理**

可以通过尝试 **能否将资源分配图完全简化** 来检测当前系统状态是否为死锁；



资源分配图：

<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210821192229544.png" alt="image-20210821192229544" style="zoom:50%;" />

其中 进程`P1`分得两个`R1`的资源，又请求一个`R2`的资源；

​		进程`P2`分得`R1`和`R2`的资源，又请求一个`R1`的资源；

​		`R1`没有空闲资源，`R2`有一个空闲资源；



简化方法：

​	找到所有“申请空闲资源的进程”，将其边全部移除；

​	上图中，`P1`满足该条件，移除后`P2`又满足该条件，继续移除后，图中不存在资源依赖关系，称为**完全简化状态**；



如果资源分配图无法简化成完全简化状态，则该状态为死锁状态；

**死锁解除**

(1) 资源剥夺法 (2) 撤销进程法 (3) 回退进程法



# 三、内存管理

由于无法将全部的程序与数据放入内存，因此操作系统需要对内存空间进行合理的划分和有效的动态分配；

## I. 功能要求

**(1) 内存的分配与回收**

​	操作系统复杂管理内存空间的分配与回收，使使用者摆脱存储分配的麻烦；

**(2) 地址转换**

​	程序中的虚拟地址与内存中的物理地址并不完全一致，因此需要提供地址转换的功能；

**(3) 内存空间扩充**

​	利用虚拟存储或自动覆盖技术，从逻辑上扩充内存；

**(4) 存储保护**

保证各个程序的存储空间不会相互干扰；

## II. 相关概念

**程序装入内存步骤**

step 1：编译

​	将用户源程序编译成若干目标模块；

step 2：链接

​	将目标模块与所需的库函数链接在一起，形成一个完整的装入模块；

​	链接有以下三种方式：

​	(1) 静态链接 - 在程序运行前，将目标模块与库链接成一个完整的可执行程序，不再拆开；

​	(2) 装入时动态编译 - 装入时，边装入边链接；

​	(3) 运行时动态链接 - 运行时，需要该模块的时候才会去链接；

step 3：装入

​	将模块装入内存中运行；

​	装入有以下三种方式：

​	(1) 绝对装入

​		编译时，编译程序产生模块的绝对地址（实际物理地址），装入时按照该绝对地址装入内存中；

​	(2) 可重定位装入（静态重定位）

​		在装入时进行地址变换；

​		装入内存时必须分配其要求的全部内存空间，若没有足够的内存则不能装入；

​	(3) 动态运行时装入 （动态重定位）

​		需要一个重定位寄存器，在程序运行时再进行地址转换；

​		可以将程序分配到不连续的存储区中；

**内存保护**

内存分配前，需要保证操作系统不受用户进程的影响且用户之间不相互影响，因此需要内存保护；

内存保护的方法：

(1) 在CPU中设置一对地址上、下限寄存器，分别存放用户可以操作的地址的上限和下限，当CPU访问地址时用来检查是否越界；

(2) 使用基址寄存器和限长寄存器，基址寄存器中含有最小的物理地址，限长寄存器中含有逻辑地址的最大值，得到一个要访问的逻辑地址后，先将其与限长寄存器对比检查是否越界，再加上基址寄存器的值后得到真正的物理地址；

**覆盖与交换**

在多程序环境中，扩充内存可以用覆盖和交换两种方法；

(1) 覆盖

​	在内存容量很小，哪怕一个大规模程序也放不下时，诞生了“覆盖”这种方法；

​	将用户空间分为一个“固定区”和若干个“可覆盖区”，把程序中经常调用的、活跃的部分放在固定区，其余部分放在外存中，当需要时调入至可覆盖区，将之前的内容覆盖掉；

(2) 交换

​	把处于等待状态的程序从内存移动到外存中，并把准备运行的程序从外存移动到内存中，即为交换；

**内部和外部碎片**

内存分配的过程中可能产生内部或外部碎片；

内部碎片 - 程序需要占用的空间小于给其分配的空间，但仍然需要占用一个完整的空间；

外部碎片 - 给内存分区的过程中留下一部分小的内存空间，它们不连续，无法为其分配程序；

​					外部碎片可用通过“紧凑”操作来消除（类似磁盘整理）；

### **连续分配方式**

表示为一个用户程序分配一个连续的内存空间；

主要分为三种分配方式：

|              | 说明                                                         | 优点                                   | 缺点                                             |
| ------------ | ------------------------------------------------------------ | -------------------------------------- | ------------------------------------------------ |
| 单一连续分配 | 用户内存空间整个供一个程序使用                               | 简单，没有外部碎片，不需要额外技术支持 | 只能用于单用户、单任务，存储利用率低，有内部碎片 |
| 固定分区分配 | 将用户内存空间分为若干固定大小的区域，每个区域可进行一道作业 | 没有外部碎片                           | 存储利用率低，有内部碎片                         |
| 动态分区分配 | 不预先划分内存，在进程装入内存时根据需要的空间大小建立分区   | 没有内部碎片                           | 存储利用率低，有外部碎片                         |

### **非连续分配方式**

允许程序分散地装入不相邻的内存分区；

(1) 分页存储管理方式

​		将进程和内存空间都以“块”为单位进行划分，进程申请内存时以块为单位进行申请；

​		对比固定分区分配，块的大小要小得多，因此，虽然基本分页存储管理方式也会产生内部碎片，但产生的碎片要小得多；

​		进程中的块称为**页 Page**，内存中的块称为**页框 PageFrame**，外存中的块直接称为**块 Block**；

​		页的大小太大会导致碎片过多，太小会影响效率，需要权衡；

​		**页的地址结构**：

​		<img src="C:\Users\dzw\AppData\Roaming\Typora\typora-user-images\image-20210822161616206.png" alt="image-20210822161616206" style="zoom:50%;" />

​			其中页号地址为12~31，表示最多有$2^{20}$个页；业内偏移的地址为0~11，表示页的大小为$2^{12}$（即KB）；

​		**页表**：记录页面中对应的物理块号，由**页表项**构成；

​					页表项类似页的地址结构（页号 + 物理内存中的块号），页表项的第二部分与地址的第二部分共同构成物理地址；

​		**基本地址变换机构**：

​			功能：用来将逻辑地址转为内存中的物理地址；

​		**快表与慢表**：

​			执行一次指令需要访问内存两次：第一次读取页表，获得物理地址；第二次从物理地址中取出指令执行；

​			为了改进，在基本地址变换机构中设置一个具有高速查找能力的**快表**，对应的内存中的页表称为**慢表**；

​			快表起记忆缓存的功能，凡是已经在慢表中查找过的页表项，都会记录在快表中，下次查询就不用经过慢表了；

​			两种查表方式：

​				① 先查快表，块表中查不到再查慢表；

​				② 快表和慢表同时查找（由于快表快，如果能查到会先返回）；

​		**两级页表**

​			将页表分级，避免页表太大查找起来耗时太长；

(2) 分段存储管理方式

​		按照用户进程中的自然段划分逻辑空间；

​		**段表**：每个进程拥有一张段表，用来实现从逻辑段到物理地址的映射；

​		**地址变换机构**

​		**段的共享和保护**

(3) 段页式管理方式

​		页式管理的优点 - 有效提高了内存利用率；

​		段式管理的优点 - 能够反映程序的逻辑结构，有利于段内共享；

​		将两种管理方式结合，先分段再分块，一个段表 + 多个页表

## III. 虚拟内存

**传统内存管理方式的缺点**

​	① 程序全部载入内存后，才能开始运行；

​	② 程序直到运行结束，都整体存在于内存中（包括处于阻塞时）；

​	导致内存资源没有得到充分的使用；

**理论依据（局部性原理）**

​	① 时间局部性 - 某条指令被执行，则不久后该指令很可能被再次执行；

​	② 空间局部性 - 某个存储单元被访问，其附近的存储单元很可能也被访问；

### **定义**

​	基于局部性原理，在程序装入内存时，只装入一部分，其余部分留在外存；

​	在执行时，若需要访问的信息不在内存中，则从外存中载入；暂时不需要的信息则从内存移入外存；

### **特征**

​	(1) 多次性

​		不需要一次全部载入内存，而是分多次被调入内存；

​	(2) 对换性

​		不需要一直停留在内存，而是在内存和外存之间频繁交换；

​	(3) 虚拟性

​		用户看到的内存容量远大于实际的内存容量；

### 实现方式

(1) 请求分页存储管理

​	建立在基础分页管理系统之上，增加了 请求调页功能 和 页面置换功能；

​	**工作机制**

​		只需要将当前需要的一部分页面装入内存中，之后运行时按需求将页面在外存和内存之间调换；

​	**页表机制**

​		页表项 = 页号 + 物理块号 + 状态位P + 访问字段A + 修改位M + 外存地址

​		状态位P - 表示该页是否已被调入内存；

​		访问字段A - 记录本页在一段时间内被访问的次数，用来参与置换算法；

​		修改位M - 表示该页在调入内存后是否被修改过；

​		外存地址 - 表示该页在外存上的地址；

​	**缺页中断**

​		每当需要访问的页不在内存中时，就会产生一个缺页中断；此时若内存有空闲的块，就会将对应页从外存中调入；

​	**地址变换机构**

​		先检索快表，若找到：

​			修改页表项中的访问字段，通过页表项中的物理块号找到物理地址；

​		若没找到：

​			去内存中查找慢表，如果对应页表项中状态为P为false，则产生缺页中断；

(2) 请求分段存储管理

(3) 请求段页式存储管理



### 页面置换算法

置换算法绝对哪页将被调出，应将之后不会或较长时间不再访问的页面调出，以降低页面更换频率；

|                               | 说明                                                         | 优缺点                                           |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------ |
| 最佳置换算法（OPT）           | 淘汰以后永不使用或最长时间内不被访问的页面（仅理论，实际做不到），通过一个CPU将要访问的页面的队列，找到其中最晚被访问的页面并淘汰 | 理想与现实存在差距                               |
| 先进先出置换算法（FIFO）      | 淘汰最早进入内存的页面                                       | 简单，但与局部性原理不符，会产生`Belady`异常     |
| 最近最久未使用置换算法（LRU） | 淘汰最近最长时间未被访问的页                                 | 性能较好，但需要寄存器和栈的硬件支持，实现开销大 |
| 时钟置换算法（CLOCK）         | 设置一个附加位，当被调入时将附加位置为1，当需要调出时优先调出附加位为0的页；若全为1则将附加位重新置为0 | 性能接近LRU，但开销更小                          |

### 页面分配策略

分配策略决定什么时候调入、从哪里调入、调入多少页；

(1) 驻留集（调入数量）

​	给一个进程分配的物理页框的集合就是该进程的驻留集；

​	分配给进程的页数越少（即驻留集越小），则内存中的进程数越多，CPU的时间利用效率越高，同时，页错误率也会越高；

​	分配给进程的页数越多（即驻留集越大），则时间利用效率越低，同时由于局部性原理，页错误率并不会持续降低；

常用的分配策略：

|                  | 说明                                                         | 优缺点                                       |
| ---------------- | ------------------------------------------------------------ | -------------------------------------------- |
| 固定分配局部置换 | 为每个进程分配一定数量的物理块，整个运行期间不变；<br />当缺页时，只能从该进程的页面中选出一页换出； | 简单，但难以确定合适的物理块数；             |
| 可变分配全局置换 | 操作系统自身也控制一个空闲物理块队列；<br />当缺页时，从空闲物理块中取出一个分配给进程； | 可能会盲目给进程加物理块，导致并发能力降低； |
| 可变分配局部置换 | 只有当进程频繁缺页时，才会给进程分配物理块（动态调整）；     | 实现复杂；                                   |

(2) 调入时机

​	① 当需要访问的页面不在内存中时调入；

​	② 预测哪些页面将要会用到，将其调入（常用于首次调入）；

(3) 从哪里调入

​	请求分页系统的外存分为两部分，用于存放文件的文件区 + 用于存放对换页面的对换区；

### 抖动

​	指刚换入的页面马上就被换出，或刚换出的页面马上就被换入；

​	产生原因：某个进程频繁访问的页面的数量大于可用的物理页面的数量；

### 工作集

​	指某段时间间隔内进程将要访问的页面的集合；



# 四、文件管理

## I. 结构

### 1. 逻辑结构

按照逻辑结构，可以分为无结构文件和有结构文件两种；

(1) 无结构文件（流式文件）

​	没有结构，查找记录时只能穷举搜索；

​	适合对基本信息单位操作不多的文件，如源程序文件、目标代码文件等；

(2) 有结构文件（记录式文件）

|              | 说明                                                         | 优缺点                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 顺序文件     | 记录一个接一个按顺序排列                                     | 批量读写效率最高，能在磁带上有效工作；<br />对单条记录的增删改查操作比较困难； |
| 索引文件     | 分为定长记录和不定长记录，定长记录可以直接根据下标查找，不定长记录需要索引表辅助查找 |                                                              |
| 索引顺序文件 | 结合了索引和顺序，先通过索引找到记录所在的组，再顺序查找找到记录 | 查找效率提高，但索引表增加了存储空间                         |
| 散列文件     | 通过散列函数决定记录的存放位置                               | 可能存在冲突                                                 |

### 2. 目录结构

**文件控制块**

类似进程控制块（PCB），操作系统中也存在文件控制块（FCB）用于管理目录；

一个FCB就是一个文件目录项，FCB的集合构成了文件目录；

**索引结点**

因为查找文件时只需要“文件名”这一信息，其他信息没有用到，因此在UNIX等系统中，将文件名和文件描述信息分开存放管理；

文件描述信息单独形成一个称为索引结点的数据结构，简称$i$结点；

文件目录的目录项中，不再包含文件名和描述信息，而是文件名和指向对应$i$结点的指针；

通过该方法，大大减小了目录项的大小，加快了文件的查询速度；

**目录结构**

|                | 说明                                 | 优缺点                                             |
| -------------- | ------------------------------------ | -------------------------------------------------- |
| 单级目录结构   | 只有一张目录表，每个文件占一个目录项 | 查找速度慢，不允许重名                             |
| 两级目录结构   | 两级目录                             | 缺乏灵活性                                         |
| 树形目录结构   | 多级目录                             | 方便进行分类，但查找文件时需要多次访问硬盘，速度慢 |
| 无环图目录结构 | 无环图                               | 方便文件共享，但管理复杂                           |

## II. 共享

### 1. 硬链接

硬链接为基于索引结点的文件共享方式；

文件目录的目录项中记录文件名与对应的索引结点，索引结点中存放一个链接计数，用于表示链接到该文件的目录项的数目；

仅当链接计数为0时，系统才会负责删除该文件；

硬链接时，用户不能随意删除文件，因为

### 2. 软链接

软链接为基于符号链实现的文件共享方式；

系统创建一个链接文件，指向源文件，将链接文件写入其他用户的目录中；

只有文件拥有者拥有文件的索引结点，其他用户只有文件的链接；

拥有链接的用户，在访问文件时，需要根据文件名逐个查找目录直到找到索引结点，多次读盘造成较大开销；

## III. 保护

### 访问控制

|                                | 说明                                                         | 优点                        | 缺点                                     |
| ------------------------------ | ------------------------------------------------------------ | --------------------------- | ---------------------------------------- |
| 根据用户身份进行控制           | 为每个文件增加一个访问控制列表（ACL），其中规定了每个用户所允许的访问类型 | 可以使用复杂的访问方法      | ACL的长度无法预计，可能会非常复杂耗时    |
| 根据用户身份进行控制（改进版） | 采用“拥有者”、“组”、“其他用户”三种用户类型                   | 避免了ACL长度无法预计的问题 |                                          |
| 口令                           | 创建文件时提供一个口令，将口令告知给共享该文件的其他用户，访问时需要提供口令 | 保密性强                    | 口令保存在系统内部，占据存储空间且不安全 |
| 密码                           | 访问文件需要提供密码                                         | 保密性强                    | 编码和译码需要耗时                       |

## IV. 文件系统实现

### 目录实现

#### 1. 线性列表

​	对应线性查找 - 简单、耗时；

#### 2. 哈希表

​	对应散列查找 - 增删改查块、有冲突；

### 文件实现

#### 1. 磁盘空间分配

|           | 说明                                                         | 优点                 | 缺点                                                         |
| --------- | ------------------------------------------------------------ | -------------------- | ------------------------------------------------------------ |
| 连续分配  | 要求每个文件在磁盘上占用一组连续的块                         | 实现简单，存取速度块 | 文件长度若增加，则其之后的文件存储位置都要移动，容易产生外部碎片 |
| 链接分配① | 隐式链接 - 每个文件对应一个磁盘块的列表，每个表块都分布在任意位置，有指针指向下一个表块； |                      | 无法直接访问盘块，只能顺序查找；表块或指针可能损坏，导致文件的损坏 |
| 链接分配② | 显式链接 - “指针”不放在盘块上，而是存放于文件分配表（FAT）中，文件分配表按顺序记录每个盘块的编号 | 提高了检索速度       |                                                              |
| 索引分配  | 把每个文件的所有盘块集中于一个索引表中                       | 支持随机访问         | 查找需要访问多次磁盘                                         |

#### 2. 文件存储空间管理

(1) 存储空间划分

​	一个文件存储在一个**文件卷**中；

​	一个文件卷可以是磁盘的一部分，也可以是多个磁盘的组合；

​	文件卷分为存储文件数据信息的**文件区**和存储文件控制信息的**目录区**；

​	文件卷在提供文件服务之前，必须由对应的程序进行初始化，划分好文件去和目录区；

(2) 存储器空间管理

​	文件存储设备分为许多大小相同的**物理块**，以块为单位进行信息交换；

​	因此，存储空间管理的实质就是对空闲的物理块的管理，负责空闲物理块的组织、分配、回收；

|            | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 空闲表法   | 适用于连续分配方式；<br />系统为外存的所有空闲区建立一个空闲盘块表，每个空闲区对应一个表项；<br />表项中记录序号、第一个空闲盘块号、空闲盘块数等信息；<br />对空闲盘块的分配与回收基于空闲盘块表实现； |
| 空闲链表法 | 分为空闲盘块链表和空闲盘区链；<br />空闲盘块链 - 以盘块为单位；<br />空闲盘区链 - 以盘区为单位（盘区中包含多个盘块）； |
| 位示图法   | 利用二进制表示盘块的空闲情况，0表示空闲，1表示已分配；       |
| 成组链接法 | 结合空闲表法与空闲链表法，多层分组，适合大型文件系统；       |



## V. 磁盘的组织和管理

### 1. 磁盘结构

磁盘 - 由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为**磁头**的导体线圈扫描获取数据；

数据存储在一组同心圆中，称为**磁道**，一个盘面有多个磁道，磁道与磁头宽度相同；

磁道划分为多个**扇区**，一个扇区称为一个**盘块**，扇区是磁盘可以寻址的最小存储单位；

一个**磁盘组**包括多个磁盘，每个磁盘都有一个磁头，所有磁头位置固定，读取数据时，磁头固定不动，磁盘在下面高速旋转，所有盘面上相对位置相同的磁道组成**柱面**；

磁盘地址表示方式：柱面号-盘面号-扇区号；

### 2. 磁盘调度算法

当多个请求同时到达时，用来绝对先为哪个请求服务；

一次磁盘读写操作时间由寻找时间、延迟时间、传输时间所决定；

**寻找时间 $T_s$** - 在读写信息之前，将磁头移动到指定磁道需要的时间；

​	假设跨越一条磁道需要时间$m$，共需要跨越$n$条磁道，启动磁臂的时间为$s$，则
$$
T_s=m\times n+s
$$
**延迟时间 $T_r$** - 磁头移动到指定扇区需要的时间；

​	设磁盘转速为$r$，则延迟时间为
$$
T_r=\frac{1}{2r}
$$
**传输时间 $T_t$** - 从磁盘读出或写入磁盘需要的时间；

​	设磁盘每秒转数为$r$，一个磁道上的字节数为$N$，每次读写的字节数为$b$，则
$$
T_t=\frac{b}{rN}
$$


